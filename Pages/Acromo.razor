@page "/"
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<PageTitle>Acromo - Teambuilding Helper</PageTitle>
<link rel="stylesheet" href="css/gen5-theme.css" />

<div class="page-header" style="text-align: center; border: none; background: transparent; padding: 2rem 0;">
    <h1><span style="font-size: 3rem;">üî¨</span> Acromo Teambuilding Helper</h1>
    <p>Analyze your Pokemon team with comprehensive competitive insights</p>
</div>

<details class="gen5-info-box">
    <summary class="gen5-summary">
        <span class="gen5-icon">‚ÑπÔ∏è</span>
        About This Tool
        <span class="gen5-arrow">‚ñº</span>
    </summary>
    <div class="gen5-content">
        <h3>What This Tool Does</h3>
        <p>
            This tool analyzes your Pokemon team in Showdown format and provides comprehensive competitive analysis.
            It displays your team with sprites, evaluates type coverage, detects team archetypes, and checks against
            competitive standards for SV OU (Generation 9 Overused tier).
        </p>
        
        <h3>Analysis Criteria</h3>
        <ul>
            <li><strong>Team Archetypes:</strong> Detects Stall, Semi-Stall, Hyper Offense, or Balanced team compositions</li>
            <li><strong>Type Coverage:</strong> Analyzes which types can hit your team for neutral or super effective damage</li>
            <li><strong>Competitive Checklist:</strong> Evaluates 15+ competitive criteria including:
                <ul>
                    <li>Entry hazards (Stealth Rock, Spikes)</li>
                    <li>Hazard removal (Rapid Spin, Defog)</li>
                    <li>Priority moves and fast Pokemon</li>
                    <li>Status immunity and type resistances</li>
                    <li>Pivoting moves and momentum control</li>
                </ul>
            </li>
        </ul>
        
        <h3>Data Sources</h3>
        <ul>
            <li><strong>PokeAPI:</strong> Pokemon sprites, types, and move data</li>
            <li><strong>Pok√©Sprite:</strong> Item sprites (including Gen 8+ items like Heavy-Duty Boots)</li>
        </ul>
    </div>
</details>

<section class="pokepaste-section">
    <div class="input-section">
        <h2>üìù Paste Your Team</h2>
        <textarea 
            class="team-input" 
            @bind="teamInput" 
            placeholder="Paste your Pokemon team here...">
        </textarea>
        <div class="input-controls">
            <button class="btn btn-primary" @onclick="ParseTeam">
                <span class="btn-icon">‚ö°</span> Parse Team
            </button>
            <button class="btn btn-secondary" @onclick="ClearInput">
                <span class="btn-icon">üóëÔ∏è</span> Clear
            </button>
        </div>
    </div>

    @if (isLoading)
    {
        <div class="loading-container">
            <div class="spinner"></div>
            <p>Loading Pokemon data...</p>
        </div>
    }

    @if (pokemonTeam.Any())
    {
        <div class="output-section">
            <div class="output-header">
                <h2>‚ú® Your Team</h2>
                <button class="btn btn-primary btn-sm" @onclick="CopyTeam">
                    <span class="btn-icon">üìã</span> Copy Team
                </button>
            </div>
            
            <div class="pokemon-grid">
                @foreach (var pokemon in pokemonTeam)
                {
                    <div class="pokemon-card">
                        <div class="pokemon-header">
                            <div class="pokemon-sprite-container">
                                @if (!string.IsNullOrEmpty(pokemon.SpriteUrl))
                                {
                                    <img src="@pokemon.SpriteUrl" alt="@pokemon.Name" class="pokemon-sprite" />
                                }
                                else
                                {
                                    <div class="sprite-placeholder">?</div>
                                }
                            </div>
                            <div class="pokemon-title">
                                <h3>@pokemon.Name @pokemon.Gender</h3>
                                @if (pokemon.Types.Any())
                                {
                                    <div class="pokemon-types">
                                        @foreach (var type in pokemon.Types)
                                        {
                                            <span class="type-badge type-@type.ToLower()">@type</span>
                                        }
                                    </div>
                                }
                                @if (!string.IsNullOrEmpty(pokemon.Item))
                                {
                                    <div class="pokemon-item-container">
                                        @if (!string.IsNullOrEmpty(pokemon.ItemSpriteUrl))
                                        {
                                            <img src="@pokemon.ItemSpriteUrl" alt="@pokemon.Item" class="item-sprite" />
                                        }
                                        <p class="pokemon-item">@@ @pokemon.Item</p>
                                    </div>
                                }
                            </div>
                        </div>
                        
                        <div class="pokemon-details">
                            @if (!string.IsNullOrEmpty(pokemon.Ability))
                            {
                                <div class="detail-row">
                                    <span class="detail-label">Ability:</span>
                                    <span class="detail-value">@pokemon.Ability</span>
                                    <span class="detail-label">EVs:</span>
                                    <span class="detail-value">@pokemon.EVs</span>
                                </div>
                            }
                            
                            @if (!string.IsNullOrEmpty(pokemon.IVs))
                            {
                                <div class="detail-row">
                                    <span class="detail-label">IVs:</span>
                                    <span class="detail-value">@pokemon.IVs</span>
                                </div>
                            }
                            
                            @if (!string.IsNullOrEmpty(pokemon.Nature))
                            {
                                <div class="detail-row">
                                    <span class="detail-label">Nature:</span>
                                    <span class="detail-value nature">@pokemon.Nature</span>
                                </div>
                            }
                        </div>
                        
                        @if (pokemon.Moves.Any())
                        {
                            <div class="pokemon-moves">
                                <h4>Moves:</h4>
                                <ul class="move-list">
                                    @foreach (var move in pokemon.Moves)
                                    {
                                        <li class="@(string.IsNullOrEmpty(move.Type) ? "" : $"type-border-{move.Type.ToLower()}")">
                                            @move.Name
                                        </li>
                                    }
                                </ul>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
    }

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger">
            ‚ö†Ô∏è @errorMessage
        </div>
    }
    
    @if (pokemonTeam.Any() && typeAnalysis != null)
    {
        <div class="type-analysis-section">
            <h2>üéØ Type Coverage Analysis</h2>
            
            @if (typeAnalysis.NeutralCoverageTypes.Any())
            {
                <div class="analysis-card">
                    <h3>‚úÖ Neutral Coverage Types</h3>
                    <p class="analysis-description">These types can hit all Pokemon on the team for at least neutral damage:</p>
                    <div class="type-badges">
                        @foreach (var type in typeAnalysis.NeutralCoverageTypes)
                        {
                            <span class="type-badge type-@type.ToLower()">@type</span>
                        }
                    </div>
                </div>
            }
            else
            {
                <div class="analysis-card">
                    <h3>‚úÖ Neutral Coverage Types</h3>
                    <p class="analysis-description">No single type can hit all Pokemon for neutral damage.</p>
                </div>
            }
            
            @if (typeAnalysis.SuperEffectiveCoverageTypes.Any())
            {
                <div class="analysis-card">
                    <h3>‚ö° Super Effective Coverage (2+ Pokemon)</h3>
                    <p class="analysis-description">These types can hit 2 or more Pokemon for super effective damage:</p>
                    @foreach (var coverage in typeAnalysis.SuperEffectiveCoverageTypes)
                    {
                        <div class="coverage-item">
                            <span class="type-badge type-@coverage.Type.ToLower()">@coverage.Type</span>
                            <span class="coverage-count">Hits @coverage.Count Pokemon</span>
                            <div class="affected-pokemon">
                                @foreach (var pokemon in coverage.AffectedPokemon)
                                {
                                    <span class="pokemon-name">@pokemon</span>
                                }
                            </div>
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="analysis-card">
                    <h3>‚ö° Super Effective Coverage (2+ Pokemon)</h3>
                    <p class="analysis-description">No type can hit 2 or more Pokemon for super effective damage.</p>
                </div>
            }
            
            @if (typeAnalysis.ImmunityNotes.Any())
            {
                <div class="analysis-card immunity-notes">
                    <h3>üõ°Ô∏è Immunity Considerations</h3>
                    <ul>
                        @foreach (var note in typeAnalysis.ImmunityNotes)
                        {
                            <li>@note</li>
                        }
                    </ul>
                </div>
            }
        </div>
    }
    
    @if (pokemonTeam.Any() && teamRating != null)
    {
        <div class="team-rating-section">
            <h2>üìä Team Rating</h2>
            
            <div class="archetype-display">
                <h3>Team Archetype</h3>
                <span class="archetype-badge archetype-@teamRating.Archetype.ToLower()">@teamRating.Archetype</span>
                <p class="archetype-description">@teamRating.ArchetypeDescription</p>
            </div>
            
            <div class="rating-checklist">
                <h3>Competitive Checklist</h3>
                <p class="checklist-intro">Evaluation based on SV OU competitive standards:</p>
                
                @foreach (var check in teamRating.CheckResults)
                {
                    <div class="check-item check-@check.Status.ToLower()">
                        <div class="check-header">
                            <span class="check-icon">@GetCheckIcon(check.Status)</span>
                            <span class="check-name">@check.Name</span>
                            <span class="check-status-badge">@check.Status</span>
                        </div>
                        <p class="check-description">@check.Description</p>
                        @if (!string.IsNullOrEmpty(check.Details))
                        {
                            <p class="check-details">@check.Details</p>
                        }
                    </div>
                }
            </div>
            
            <div class="rating-summary">
                <h3>Overall Score</h3>
                <div class="score-display">
                    <div class="score-circle">
                        <span class="score-value">@teamRating.PassedChecks</span>
                        <span class="score-total">/ @teamRating.TotalChecks</span>
                    </div>
                    <div class="score-grade">
                        <span class="grade-letter">@teamRating.Grade</span>
                        <p class="grade-description">@teamRating.GradeDescription</p>
                    </div>
                </div>
            </div>
        </div>
    }
</section>


@code {
    private string teamInput = "";
    private List<PokemonData> pokemonTeam = new();
    private bool isLoading = false;
    private string errorMessage = "";
    private TypeAnalysis? typeAnalysis = null;
    private TeamRating? teamRating = null;
    private Dictionary<string, string> moveTypeCache = new();

    private class PokemonData
    {
        public string Name { get; set; } = "";
        public string Gender { get; set; } = "";
        public string Item { get; set; } = "";
        public string Ability { get; set; } = "";
        public string TeraType { get; set; } = "";
        public string EVs { get; set; } = "";
        public string IVs { get; set; } = "";
        public string Nature { get; set; } = "";

        public List<MoveInfo> Moves { get; set; } = new();
        public string SpriteUrl { get; set; } = "";
        public List<string> Types { get; set; } = new();
        public string ItemSpriteUrl { get; set; } = "";
    }

    private class MoveInfo
    {
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";
    }
    
    private class TeamRating
    {
        public string Archetype { get; set; } = "Balanced";
        public string ArchetypeDescription { get; set; } = "";
        public List<CheckResult> CheckResults { get; set; } = new();
        public int PassedChecks { get; set; }
        public int TotalChecks { get; set; }
        public string Grade { get; set; } = "";
        public string GradeDescription { get; set; } = "";
    }
    
    private class CheckResult
    {
        public string Name { get; set; } = "";
        public string Status { get; set; } = ""; // Pass, Fail, Skip, Warning
        public string Description { get; set; } = "";
        public string Details { get; set; } = "";
    }
    
    private string GetCheckIcon(string status)
    {
        return status switch
        {
            "Pass" => "‚úÖ",
            "Fail" => "‚ùå",
            "Skip" => "‚è≠Ô∏è",
            "Warning" => "‚ö†Ô∏è",
            _ => "‚ùì"
        };
    }
    
    private class TypeAnalysis
    {
        public List<string> NeutralCoverageTypes { get; set; } = new();
        public List<SuperEffectiveCoverage> SuperEffectiveCoverageTypes { get; set; } = new();
        public List<string> ImmunityNotes { get; set; } = new();
    }
    
    private class SuperEffectiveCoverage
    {
        public string Type { get; set; } = "";
        public int Count { get; set; }
        public List<string> AffectedPokemon { get; set; } = new();
    }

    private async Task ParseTeam()
    {
        if (string.IsNullOrWhiteSpace(teamInput))
        {
            errorMessage = "Please paste a Pokemon team first!";
            return;
        }

        errorMessage = "";
        isLoading = true;
        pokemonTeam.Clear();

        try
        {
            var lines = teamInput.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            PokemonData? currentPokemon = null;

            foreach (var line in lines)
            {
                var trimmedLine = line.Trim();
                
                // New Pokemon (first line with name)
                if (!trimmedLine.StartsWith("-") && 
                    !trimmedLine.StartsWith("Ability:") && 
                    !trimmedLine.StartsWith("Tera Type:") &&
                    !trimmedLine.StartsWith("EVs:") &&
                    !trimmedLine.StartsWith("IVs:") &&
                    !trimmedLine.Contains("Nature"))
                {
                    if (currentPokemon != null)
                    {
                        pokemonTeam.Add(currentPokemon);
                    }
                    
                    currentPokemon = new PokemonData();
                    
                    // Parse name, gender, and item
                    var parts = trimmedLine.Split('@');
                    var namePart = parts[0].Trim();
                    
                    // Extract gender
                    if (namePart.Contains("(M)"))
                    {
                        currentPokemon.Gender = "‚ôÇ";
                        namePart = namePart.Replace("(M)", "").Trim();
                    }
                    else if (namePart.Contains("(F)"))
                    {
                        currentPokemon.Gender = "‚ôÄ";
                        namePart = namePart.Replace("(F)", "").Trim();
                    }
                    
                    // Handle nicknames: "Nickname (Species)" -> extract "Species"
                    // If the name ends with ')' and has a '(', it likely has a nickname
                    if (namePart.EndsWith(")") && namePart.Contains("("))
                    {
                        int lastOpenParen = namePart.LastIndexOf('(');
                        if (lastOpenParen != -1)
                        {
                            // Extract the text inside the last set of parentheses
                            var potentialName = namePart.Substring(lastOpenParen + 1, namePart.Length - lastOpenParen - 2).Trim();
                            if (!string.IsNullOrEmpty(potentialName))
                            {
                                currentPokemon.Name = potentialName;
                            }
                            else
                            {
                                currentPokemon.Name = namePart;
                            }
                        }
                        else
                        {
                            currentPokemon.Name = namePart;
                        }
                    }
                    else
                    {
                        currentPokemon.Name = namePart;
                    }
                    
                    if (parts.Length > 1)
                    {
                        currentPokemon.Item = parts[1].Trim();
                    }
                }
                else if (currentPokemon != null)
                {
                    // Parse other attributes
                    if (trimmedLine.StartsWith("Ability:"))
                    {
                        currentPokemon.Ability = trimmedLine.Replace("Ability:", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("Tera Type:"))
                    {
                        currentPokemon.TeraType = trimmedLine.Replace("Tera Type:", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("EVs:"))
                    {
                        currentPokemon.EVs = trimmedLine.Replace("EVs:", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("IVs:"))
                    {
                        currentPokemon.IVs = trimmedLine.Replace("IVs:", "").Trim();
                    }
                    else if (trimmedLine.Contains("Nature"))
                    {
                        currentPokemon.Nature = trimmedLine.Replace("Nature", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("-"))
                    {
                        var moveName = trimmedLine.Substring(1).Trim();
                        currentPokemon.Moves.Add(new MoveInfo { Name = moveName });
                    }
                }
            }
            
            // Add last Pokemon
            if (currentPokemon != null)
            {
                pokemonTeam.Add(currentPokemon);
            }
            
            // Fetch sprites and data for all pokemon
            foreach (var p in pokemonTeam)
            {
                await FetchPokemonSprite(p);
            }
            
            // Calculate type analysis
            typeAnalysis = CalculateTypeAnalysis();
            
            // Calculate team rating
            teamRating = CalculateTeamRating();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error parsing team: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task FetchPokemonSprite(PokemonData pokemon)
    {
        try
        {
            // Convert Pokemon name to API format (lowercase, replace spaces with hyphens)
            var apiName = pokemon.Name.ToLower()
                .Replace(" ", "-")
                .Replace("'", "")
                .Replace(".", "")
                .Replace(":", "");
            
            var response = await Http.GetFromJsonAsync<PokeApiResponse>($"https://pokeapi.co/api/v2/pokemon/{apiName}");
            
            if (response?.Sprites?.FrontDefault != null)
            {
                pokemon.SpriteUrl = response.Sprites.FrontDefault;
            }
            
            // Fetch types
            if (response?.Types != null)
            {
                pokemon.Types = response.Types.Select(t => t.Type?.Name ?? "").Where(n => !string.IsNullOrEmpty(n)).ToList();
            }
        }
        catch
        {
            // If sprite fetch fails, leave it empty (will show placeholder)
            pokemon.SpriteUrl = "";
        }
        
        // Fetch item sprite if item exists
        if (!string.IsNullOrEmpty(pokemon.Item))
        {
            await FetchItemSprite(pokemon);
        }
        
        // Fetch move types
        foreach (var move in pokemon.Moves)
        {
            await FetchMoveType(move);
        }
        StateHasChanged(); // Ensure UI updates after fetching
    }
    
    private async Task FetchMoveType(MoveInfo move)
    {
        // Check cache first
        if (moveTypeCache.ContainsKey(move.Name.ToLower()))
        {
            move.Type = moveTypeCache[move.Name.ToLower()];
            return;
        }

        try
        {
            // Convert move name to API format
            var apiName = move.Name.ToLower()
                .Replace(" ", "-")
                .Replace("'", "")
                .Replace(".", "")
                .Replace(":", "");
            
            var options = new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };

            var response = await Http.GetFromJsonAsync<MoveApiResponse>($"https://pokeapi.co/api/v2/move/{apiName}", options);
            
            if (response?.Type?.Name != null)
            {
                Console.WriteLine($"Fetched type for {move.Name}: {response.Type.Name}");
                move.Type = response.Type.Name;
                moveTypeCache[move.Name.ToLower()] = move.Type;
            }
            else
            {
                Console.WriteLine($"Failed to fetch type for {move.Name} (Response or Type was null)");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching move type for {move.Name}: {ex.Message}");
        }
    }
    
    private async Task FetchItemSprite(PokemonData pokemon)
    {
        try
        {
            // Convert item name to API format (lowercase, replace spaces with hyphens)
            var apiItemName = pokemon.Item.ToLower()
                .Replace(" ", "-")
                .Replace("'", "")
                .Replace(".", "")
                .Replace(":", "");
            
            var response = await Http.GetFromJsonAsync<ItemApiResponse>($"https://pokeapi.co/api/v2/item/{apiItemName}");
            
            if (response?.Sprites?.Default != null)
            {
                pokemon.ItemSpriteUrl = response.Sprites.Default;
            }
            else
            {
                // Fallback to Pok√©Sprite database for newer items (Gen 8+) that don't have sprites in PokeAPI
                // Pok√©Sprite has sprites for items like Heavy-Duty Boots
                pokemon.ItemSpriteUrl = $"https://raw.githubusercontent.com/msikma/pokesprite/master/items/hold-item/{apiItemName}.png";
            }
        }
        catch
        {
            // If item sprite fetch fails, try Pok√©Sprite as last resort
            try
            {
                var apiItemName = pokemon.Item.ToLower()
                    .Replace(" ", "-")
                    .Replace("'", "")
                    .Replace(".", "")
                    .Replace(":", "");
                pokemon.ItemSpriteUrl = $"https://raw.githubusercontent.com/msikma/pokesprite/master/items/hold-item/{apiItemName}.png";
            }
            catch
            {
                // If all fails, leave it empty
                pokemon.ItemSpriteUrl = "";
            }
        }
    }
    
    private TypeAnalysis CalculateTypeAnalysis()
    {
        var analysis = new TypeAnalysis();
        var allTypes = new[] { "Normal", "Fire", "Water", "Electric", "Grass", "Ice", "Fighting", "Poison", 
                               "Ground", "Flying", "Psychic", "Bug", "Rock", "Ghost", "Dragon", "Dark", "Steel", "Fairy" };
        
        // Abilities that grant immunities
        var immunityAbilities = new Dictionary<string, string[]>
        {
            { "Flash Fire", new[] { "fire" } },
            { "Water Absorb", new[] { "water" } },
            { "Dry Skin", new[] { "water" } },
            { "Storm Drain", new[] { "water" } },
            { "Sap Sipper", new[] { "grass" } },
            { "Levitate", new[] { "ground" } },
            { "Volt Absorb", new[] { "electric" } },
            { "Lightning Rod", new[] { "electric" } },
            { "Motor Drive", new[] { "electric" } },
            { "Good as Gold", new[] { "status" } }, // Immune to status moves
            { "Thick Fat", new string[] { } }, // Reduces damage but doesn't grant immunity
            { "Wonder Guard", new string[] { } }, // Special case
        };
        
        // Items that grant immunities
        var immunityItems = new Dictionary<string, string[]>
        {
            { "Air Balloon", new[] { "ground" } },
            { "Heavy-Duty Boots", new string[] { } }, // Entry hazards, not type immunity
        };
        
        foreach (var attackType in allTypes)
        {
            int neutralCount = 0;
            int superEffectiveCount = 0;
            var affectedBySuper = new List<string>();
            
            foreach (var pokemon in pokemonTeam)
            {
                var effectiveness = GetTypeEffectiveness(attackType.ToLower(), pokemon, immunityAbilities, immunityItems);
                
                if (effectiveness >= 1.0) neutralCount++;
                if (effectiveness > 1.0)
                {
                    superEffectiveCount++;
                    affectedBySuper.Add(pokemon.Name);
                }
            }
            
            // Check for neutral coverage (hits all Pokemon for at least neutral damage)
            if (neutralCount == pokemonTeam.Count)
            {
                analysis.NeutralCoverageTypes.Add(attackType);
            }
            
            // Check for super effective coverage (hits 2+ Pokemon for super effective damage)
            if (superEffectiveCount >= 2)
            {
                analysis.SuperEffectiveCoverageTypes.Add(new SuperEffectiveCoverage
                {
                    Type = attackType,
                    Count = superEffectiveCount,
                    AffectedPokemon = affectedBySuper
                });
            }
        }
        
        // Sort super effective coverage by count (descending)
        analysis.SuperEffectiveCoverageTypes = analysis.SuperEffectiveCoverageTypes
            .OrderByDescending(c => c.Count)
            .ToList();
        
        // Add immunity notes
        foreach (var pokemon in pokemonTeam)
        {
            if (!string.IsNullOrEmpty(pokemon.Ability))
            {
                if (immunityAbilities.ContainsKey(pokemon.Ability))
                {
                    var immuneTypes = immunityAbilities[pokemon.Ability];
                    if (immuneTypes.Any())
                    {
                        analysis.ImmunityNotes.Add($"{pokemon.Name} with {pokemon.Ability} is immune to {string.Join(", ", immuneTypes)} type moves");
                    }
                }
            }
            
            if (!string.IsNullOrEmpty(pokemon.Item))
            {
                if (immunityItems.ContainsKey(pokemon.Item))
                {
                    var immuneTypes = immunityItems[pokemon.Item];
                    if (immuneTypes.Any())
                    {
                        analysis.ImmunityNotes.Add($"{pokemon.Name} holding {pokemon.Item} is immune to {string.Join(", ", immuneTypes)} type moves");
                    }
                }
            }
        }
        
        return analysis;
    }
    
    private double GetTypeEffectiveness(string attackType, PokemonData pokemon, 
        Dictionary<string, string[]> immunityAbilities, Dictionary<string, string[]> immunityItems)
    {
        // Check for ability immunity
        if (!string.IsNullOrEmpty(pokemon.Ability) && immunityAbilities.ContainsKey(pokemon.Ability))
        {
            if (immunityAbilities[pokemon.Ability].Contains(attackType))
                return 0.0;
        }
        
        // Check for item immunity
        if (!string.IsNullOrEmpty(pokemon.Item) && immunityItems.ContainsKey(pokemon.Item))
        {
            if (immunityItems[pokemon.Item].Contains(attackType))
                return 0.0;
        }
        
        // Calculate base type effectiveness
        double effectiveness = 1.0;
        
        foreach (var defenderType in pokemon.Types)
        {
            effectiveness *= GetSingleTypeEffectiveness(attackType, defenderType);
        }
        
        return effectiveness;
    }
    
    private double GetSingleTypeEffectiveness(string attackType, string defenderType)
    {
        // Type effectiveness chart
        var typeChart = new Dictionary<string, Dictionary<string, double>>
        {
            ["normal"] = new() { ["rock"] = 0.5, ["ghost"] = 0.0, ["steel"] = 0.5 },
            ["fire"] = new() { ["fire"] = 0.5, ["water"] = 0.5, ["grass"] = 2.0, ["ice"] = 2.0, ["bug"] = 2.0, ["rock"] = 0.5, ["dragon"] = 0.5, ["steel"] = 2.0 },
            ["water"] = new() { ["fire"] = 2.0, ["water"] = 0.5, ["grass"] = 0.5, ["ground"] = 2.0, ["rock"] = 2.0, ["dragon"] = 0.5 },
            ["electric"] = new() { ["water"] = 2.0, ["electric"] = 0.5, ["grass"] = 0.5, ["ground"] = 0.0, ["flying"] = 2.0, ["dragon"] = 0.5 },
            ["grass"] = new() { ["fire"] = 0.5, ["water"] = 2.0, ["grass"] = 0.5, ["poison"] = 0.5, ["ground"] = 2.0, ["flying"] = 0.5, ["bug"] = 0.5, ["rock"] = 2.0, ["dragon"] = 0.5, ["steel"] = 0.5 },
            ["ice"] = new() { ["fire"] = 0.5, ["water"] = 0.5, ["grass"] = 2.0, ["ice"] = 0.5, ["ground"] = 2.0, ["flying"] = 2.0, ["dragon"] = 2.0, ["steel"] = 0.5 },
            ["fighting"] = new() { ["normal"] = 2.0, ["ice"] = 2.0, ["poison"] = 0.5, ["flying"] = 0.5, ["psychic"] = 0.5, ["bug"] = 0.5, ["rock"] = 2.0, ["ghost"] = 0.0, ["dark"] = 2.0, ["steel"] = 2.0, ["fairy"] = 0.5 },
            ["poison"] = new() { ["grass"] = 2.0, ["poison"] = 0.5, ["ground"] = 0.5, ["rock"] = 0.5, ["ghost"] = 0.5, ["steel"] = 0.0, ["fairy"] = 2.0 },
            ["ground"] = new() { ["fire"] = 2.0, ["electric"] = 2.0, ["grass"] = 0.5, ["poison"] = 2.0, ["flying"] = 0.0, ["bug"] = 0.5, ["rock"] = 2.0, ["steel"] = 2.0 },
            ["flying"] = new() { ["electric"] = 0.5, ["grass"] = 2.0, ["fighting"] = 2.0, ["bug"] = 2.0, ["rock"] = 0.5, ["steel"] = 0.5 },
            ["psychic"] = new() { ["fighting"] = 2.0, ["poison"] = 2.0, ["psychic"] = 0.5, ["dark"] = 0.0, ["steel"] = 0.5 },
            ["bug"] = new() { ["fire"] = 0.5, ["grass"] = 2.0, ["fighting"] = 0.5, ["poison"] = 0.5, ["flying"] = 0.5, ["psychic"] = 2.0, ["ghost"] = 0.5, ["dark"] = 2.0, ["steel"] = 0.5, ["fairy"] = 0.5 },
            ["rock"] = new() { ["fire"] = 2.0, ["ice"] = 2.0, ["fighting"] = 0.5, ["ground"] = 0.5, ["flying"] = 2.0, ["bug"] = 2.0, ["steel"] = 0.5 },
            ["ghost"] = new() { ["normal"] = 0.0, ["psychic"] = 2.0, ["ghost"] = 2.0, ["dark"] = 0.5 },
            ["dragon"] = new() { ["dragon"] = 2.0, ["steel"] = 0.5, ["fairy"] = 0.0 },
            ["dark"] = new() { ["fighting"] = 0.5, ["psychic"] = 2.0, ["ghost"] = 2.0, ["dark"] = 0.5, ["fairy"] = 0.5 },
            ["steel"] = new() { ["fire"] = 0.5, ["water"] = 0.5, ["electric"] = 0.5, ["ice"] = 2.0, ["rock"] = 2.0, ["steel"] = 0.5, ["fairy"] = 2.0 },
            ["fairy"] = new() { ["fire"] = 0.5, ["fighting"] = 2.0, ["poison"] = 0.5, ["dragon"] = 2.0, ["dark"] = 2.0, ["steel"] = 0.5 }
        };
        
        if (typeChart.ContainsKey(attackType) && typeChart[attackType].ContainsKey(defenderType))
        {
            return typeChart[attackType][defenderType];
        }
        
        return 1.0; // Neutral effectiveness
    }
    
    private TeamRating CalculateTeamRating()
    {
        var rating = new TeamRating();
        var checks = new List<CheckResult>();
        
        // Detect team archetype
        var (archetype, description) = DetectArchetype();
        rating.Archetype = archetype;
        rating.ArchetypeDescription = description;
        
        bool isStall = archetype == "Stall";
        bool isSemiStall = archetype == "Semi-Stall";
        bool isHO = archetype == "Hyper Offense";
        
        // Priority moves list
        var priorityMoves = new[] { "Extreme Speed", "Sucker Punch", "Shadow Sneak", "Aqua Jet", "Ice Shard",
            "Mach Punch", "Bullet Punch", "Vacuum Wave", "Water Shuriken", "Accelerock", "Quick Attack",
            "First Impression", "Jet Punch", "Aqua Step", "Grassy Glide", "Fake Out", "Thunderclap" };
        
        // 1. Priority Move Check
        if (!isStall && !isSemiStall)
        {
            var priorityUsers = pokemonTeam
                .Where(p => p.Moves.Any(m => priorityMoves.Contains(m.Name)))
                .Select(p => new { 
                    Pokemon = p.Name, 
                    Moves = p.Moves.Where(m => priorityMoves.Contains(m.Name)).Select(m => m.Name).ToList() 
                })
                .ToList();
            
            var hasPriority = priorityUsers.Any();
            var detailsText = hasPriority 
                ? $"Found: {string.Join(", ", priorityUsers.Select(pu => $"{pu.Pokemon} ({string.Join(", ", pu.Moves)})"))}" 
                : "No priority moves found. Consider adding Extreme Speed, Sucker Punch, or Aqua Jet";
            
            checks.Add(new CheckResult
            {
                Name = "Priority Move",
                Status = hasPriority ? "Pass" : "Fail",
                Description = "Team needs at least one Pokemon with a priority move",
                Details = detailsText
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Priority Move", Status = "Skip", Description = $"{archetype} teams don't require priority moves" });
        }
        
        // 2. Fast Pokemon Check (440+ speed)
        if (!isStall && !isSemiStall)
        {
            var hasFastMon = pokemonTeam.Any(p => p.EVs.Contains("252 Spe") && (p.Nature.Contains("Jolly") || p.Nature.Contains("Timid")));
            checks.Add(new CheckResult
            {
                Name = "Fast Pokemon",
                Status = hasFastMon ? "Pass" : "Warning",
                Description = "Team needs a Pokemon faster than Choice Scarf Gholdengo (440 speed)",
                Details = hasFastMon ? "Found Pokemon with max speed investment" : "Consider adding a fast Pokemon with 252 Spe EVs and Jolly/Timid nature"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Fast Pokemon", Status = "Skip", Description = $"{archetype} teams don't require fast Pokemon" });
        }
        
        // 3. Hazards Check
        var hasRocks = pokemonTeam.Any(p => p.Moves.Any(m => m.Name == "Stealth Rock"));
        var hasSpikes = pokemonTeam.Any(p => p.Moves.Any(m => m.Name == "Spikes"));
        var hasStickyWeb = pokemonTeam.Any(p => p.Moves.Any(m => m.Name == "Sticky Web"));
        var hasScreens = pokemonTeam.Any(p => p.Moves.Any(m => m.Name.Contains("Light Screen") || m.Name.Contains("Reflect") || m.Name.Contains("Aurora Veil")));
        
        if (hasStickyWeb || hasScreens)
        {
            checks.Add(new CheckResult
            {
                Name = "Entry Hazards",
                Status = "Pass",
                Description = "Sticky Web or Screens team detected",
                Details = hasStickyWeb ? "Sticky Web team" : "Screens HO team"
            });
        }
        else
        {
            checks.Add(new CheckResult
            {
                Name = "Entry Hazards",
                Status = hasRocks ? "Pass" : "Fail",
                Description = "Team needs Stealth Rock (Spikes optional)",
                Details = hasRocks ? (hasSpikes ? "Has Stealth Rock and Spikes" : "Has Stealth Rock") : "Missing Stealth Rock - critical for chip damage"
            });
        }
        
        // 4. Hazard Control Check
        var hazardRemovalMoves = new[] { "Rapid Spin", "Defog", "Mortal Spin", "Tidy Up", "Court Change" };
        var hasHazardControl = pokemonTeam.Any(p => p.Moves.Any(m => hazardRemovalMoves.Contains(m.Name)));
        var heavyBootsCount = pokemonTeam.Count(p => p.Item.Contains("Heavy-Duty Boots"));
        
        if (!isHO && heavyBootsCount < 3)
        {
            checks.Add(new CheckResult
            {
                Name = "Hazard Control",
                Status = hasHazardControl ? "Pass" : "Fail",
                Description = "Team needs hazard removal unless HO or 3+ Heavy-Duty Boots",
                Details = hasHazardControl ? $"Has hazard removal" : $"No hazard removal and only {heavyBootsCount} Heavy-Duty Boots"
            });
        }
        else
        {
            checks.Add(new CheckResult
            {
                Name = "Hazard Control",
                Status = "Skip",
                Description = isHO ? "Hyper Offense teams don't require hazard control" : $"Team has {heavyBootsCount} Heavy-Duty Boots"
            });
        }
        
        // 5. Toxic Spikes Absorber
        var poisonGrounded = pokemonTeam.Count(p => 
            p.Types.Contains("poison") && 
            !p.Types.Contains("flying") && 
            p.Ability != "Levitate" && 
            !p.Item.Contains("Air Balloon"));
        var steelCount = pokemonTeam.Count(p => p.Types.Contains("steel"));
        var flyingCount = pokemonTeam.Count(p => p.Types.Contains("flying"));
        
        if (isHO || heavyBootsCount >= 3 || steelCount + flyingCount >= 3)
        {
            checks.Add(new CheckResult
            {
                Name = "Toxic Spikes Absorber",
                Status = "Skip",
                Description = isHO ? "Hyper Offense teams don't require hazard control" : $"Team has {heavyBootsCount} Heavy-Duty Boots or {steelCount + flyingCount} Steel/Flying types"
            });
        }
        else
        {
            checks.Add(new CheckResult
            {
                Name = "Toxic Spikes Absorber",
                Status = poisonGrounded > 0 ? "Pass" : "Warning",
                Description = "Team needs a grounded Poison-type to absorb Toxic Spikes",
                Details = poisonGrounded > 0 ? $"Has {poisonGrounded} grounded Poison-type(s)" : "No grounded Poison-type found"
            });
        }
        
        // 6. Status Immunity
        var hasGroundElectric = pokemonTeam.Any(p => p.Types.Contains("ground") || p.Types.Contains("electric"));
        var hasFire = pokemonTeam.Any(p => p.Types.Contains("fire"));
        var hasSteelPoison = pokemonTeam.Any(p => p.Types.Contains("steel") || p.Types.Contains("poison"));
        var hasSpecialAbility = pokemonTeam.Any(p => new[] { "Magic Guard", "Poison Heal", "Purifying Salt", "Good as Gold" }.Contains(p.Ability));
        
        var statusImmunities = new List<string>();
        if (hasGroundElectric) statusImmunities.Add("Thunder Wave");
        if (hasFire) statusImmunities.Add("Burn");
        if (hasSteelPoison) statusImmunities.Add("Toxic");
        if (hasSpecialAbility) statusImmunities.Add("Multiple");
        
        checks.Add(new CheckResult
        {
            Name = "Status Immunity",
            Status = statusImmunities.Count >= 2 ? "Pass" : "Warning",
            Description = "Team needs immunity to major status conditions",
            Details = statusImmunities.Any() ? $"Immune to: {string.Join(", ", statusImmunities)}" : "No status immunities found"
        });
        
        // 7. Type Resistance (for non-HO)
        if (!isHO)
        {
            var allTypes = new[] { "normal", "fire", "water", "electric", "grass", "ice", "fighting", "poison",
                "ground", "flying", "psychic", "bug", "rock", "ghost", "dragon", "dark", "steel", "fairy" };
            var resistedTypes = 0;
            
            foreach (var type in allTypes)
            {
                foreach (var pokemon in pokemonTeam)
                {
                    var effectiveness = 1.0;
                    foreach (var defType in pokemon.Types)
                    {
                        effectiveness *= GetSingleTypeEffectiveness(type, defType);
                    }
                    if (effectiveness < 1.0)
                    {
                        resistedTypes++;
                        break;
                    }
                }
            }
            
            checks.Add(new CheckResult
            {
                Name = "Type Resistance",
                Status = resistedTypes == 18 ? "Pass" : "Warning",
                Description = "Team should resist all 18 types",
                Details = $"Resists {resistedTypes}/18 types"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Type Resistance", Status = "Skip", Description = "HO teams don't require full type coverage" });
        }
        
        // 8. Steel Type
        if (!isStall && !isHO)
        {
            checks.Add(new CheckResult
            {
                Name = "Steel Type",
                Status = steelCount > 0 ? "Pass" : "Warning",
                Description = "Having a Steel-type is highly recommended",
                Details = steelCount > 0 ? $"Has {steelCount} Steel-type(s)" : "No Steel-type found - consider adding one for defensive utility"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Steel Type", Status = "Skip", Description = $"{archetype} teams don't require Steel-types" });
        }
        
        // 9. Ground Immunity
        var hasGroundImmunity = pokemonTeam.Any(p => 
            p.Ability == "Levitate" || 
            p.Types.Contains("flying") || 
            p.Item.Contains("Air Balloon") ||
            p.Ability == "Grassy Surge");
        
        checks.Add(new CheckResult
        {
            Name = "Ground Immunity",
            Status = hasGroundImmunity ? "Pass" : "Warning",
            Description = "Team needs Ground immunity (Levitate/Flying/Air Balloon) or a Grassy Surge pokemon",
            Details = hasGroundImmunity ? "Has Ground immunity" : "No Ground immunity found"
        });
        
        // 10. Electric Immunity
        if (!isHO)
        {
            var hasElectricImmunity = pokemonTeam.Any(p => 
                p.Types.Contains("ground") || 
                p.Ability == "Lightning Rod" || 
                p.Ability == "Volt Absorb");
            
            checks.Add(new CheckResult
            {
                Name = "Electric Immunity",
                Status = hasElectricImmunity ? "Pass" : "Warning",
                Description = "Team needs Electric immunity (Ground-type/Lightning Rod/Volt Absorb)",
                Details = hasElectricImmunity ? "Has Electric immunity" : "No Electric immunity found"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Electric Immunity", Status = "Skip", Description = "HO teams don't require Electric immunity" });
        }
        
        // 11. Pivoting Moves
        if (!isStall && !isHO)
        {
            var pivotMoves = new[] { "U-turn", "Volt Switch", "Flip Turn", "Parting Shot", "Teleport", "Chilling Reception" };
            var hasPivot = pokemonTeam.Any(p => p.Moves.Any(m => pivotMoves.Contains(m.Name)));
            
            checks.Add(new CheckResult
            {
                Name = "Pivoting Moves",
                Status = hasPivot ? "Pass" : "Warning",
                Description = "Team needs pivoting moves for momentum",
                Details = hasPivot ? "Has pivoting moves" : "No pivoting moves found - consider U-turn or Volt Switch"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Pivoting Moves", Status = "Skip", Description = $"{archetype} teams don't require pivoting moves" });
        }
        
        // 12. Knock Off User
        if (!isHO)
        {
            var hasKnockOff = pokemonTeam.Any(p => p.Moves.Any(m => m.Name == "Knock Off"));
            checks.Add(new CheckResult
            {
                Name = "Knock Off User",
                Status = hasKnockOff ? "Pass" : "Warning",
                Description = "Team should have Knock Off for item removal",
                Details = hasKnockOff ? "Has Knock Off" : "No Knock Off found"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Knock Off User", Status = "Skip", Description = "HO teams don't require Knock Off" });
        }
        
        // 13. Knock Off Absorber
        var knockOffAbsorbers = new[] { "Corviknight", "Gliscor", "Clefable", "Great Tusk", "Alomomola", "Landorus-Therian", "Zapdos" };
        var hasKnockOffAbsorber = pokemonTeam.Any(p => 
            p.Ability == "Sticky Hold" || 
            knockOffAbsorbers.Contains(p.Name) ||
            p.Item.Contains("Booster Energy"));
        
        checks.Add(new CheckResult
        {
            Name = "Knock Off Absorber",
            Status = hasKnockOffAbsorber ? "Pass" : "Warning",
            Description = "Team should have a Knock Off absorber",
            Details = hasKnockOffAbsorber ? "Has Knock Off absorber" : "No Knock Off absorber found"
        });
        
        // 14. Contact Punisher
        if (!isStall && !isHO)
        {
            var hasContactPunisher = pokemonTeam.Any(p => 
                new[] { "Static", "Flame Body", "Rough Skin" }.Contains(p.Ability) ||
                p.Item.Contains("Rocky Helmet"));
            
            checks.Add(new CheckResult
            {
                Name = "Contact Punisher",
                Status = hasContactPunisher ? "Pass" : "Warning",
                Description = "Team should have contact punishment (Static/Flame Body/Rough Skin/Rocky Helmet)",
                Details = hasContactPunisher ? "Has contact punisher" : "No contact punisher found"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Contact Punisher", Status = "Skip", Description = $"{archetype} teams don't require contact punishers" });
        }
        
        // 15. Physical and Special Attackers
        if (!isStall && !isSemiStall)
        {
            var hasPhysical = pokemonTeam.Any(p => p.EVs.Contains("252 Atk"));
            var hasSpecial = pokemonTeam.Any(p => p.EVs.Contains("252 SpA"));
            
            checks.Add(new CheckResult
            {
                Name = "Mixed Offense",
                Status = (hasPhysical && hasSpecial) ? "Pass" : "Warning",
                Description = "Team should have both physical and special attackers",
                Details = $"Physical: {(hasPhysical ? "Yes" : "No")}, Special: {(hasSpecial ? "Yes" : "No")}"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Mixed Offense", Status = "Skip", Description = $"{archetype} teams don't require mixed offense" });
        }
        
        rating.CheckResults = checks;
        rating.PassedChecks = checks.Count(c => c.Status == "Pass");
        rating.TotalChecks = checks.Count(c => c.Status != "Skip");
        
        // Calculate grade
        var passRate = rating.TotalChecks > 0 ? (double)rating.PassedChecks / rating.TotalChecks : 0;
        if (passRate >= 0.9) { rating.Grade = "S"; rating.GradeDescription = "Excellent - Competitive ready!"; }
        else if (passRate >= 0.8) { rating.Grade = "A"; rating.GradeDescription = "Great - Minor improvements needed"; }
        else if (passRate >= 0.7) { rating.Grade = "B"; rating.GradeDescription = "Good - Some weaknesses to address"; }
        else if (passRate >= 0.6) { rating.Grade = "C"; rating.GradeDescription = "Average - Needs significant work"; }
        else { rating.Grade = "D"; rating.GradeDescription = "Poor - Major issues to fix"; }
        
        return rating;
    }
    
    private (string archetype, string description) DetectArchetype()
    {
        // Detect Stall and Semi-Stall
        var defensiveAbilities = new[] { "Unaware", "Regenerator", "Natural Cure", "Poison Heal", "Pressure", "Magic Bounce" };
        var defensiveMoves = new[] { "Rest", "Recover", "Roost", "Soft-Boiled", "Wish", "Slack Off" };
        
        var bulkyCount = pokemonTeam.Count(p => 
            defensiveAbilities.Contains(p.Ability) ||
            p.Moves.Any(m => defensiveMoves.Contains(m.Name)) ||
            (p.EVs.Contains("252 HP") && (p.EVs.Contains("252 Def") || p.EVs.Contains("252 SpD"))));
        
        // Count semi-stall breakers (utility-based Pokemon with progress-making moves)
        var progressMoves = new[] { "U-turn", "Volt Switch", "Flip Turn", "Knock Off", "Taunt", "Parting Shot" };
        var semiStallBreakerCount = pokemonTeam.Count(p =>
            p.Moves.Any(m => progressMoves.Contains(m.Name)));
        
        // Detect Semi-Stall (4-5 bulky Pokemon + 1-2 utility breakers)
        if (bulkyCount >= 4 && bulkyCount <= 5 && semiStallBreakerCount >= 1 && semiStallBreakerCount <= 2)
        {
            return ("Semi-Stall", "Defensive core with utility breakers that force progress through pivoting, item removal, and disruption");
        }
        
        // Detect Pure Stall (all 6 Pokemon are bulky)
        if (bulkyCount >= 6)
        {
            return ("Stall", "Defensive team focused on outlasting opponents with entry hazards and recovery");
        }
        
        // Detect Hyper Offense
        var setupMoves = new[] { "Swords Dance", "Dragon Dance", "Nasty Plot", "Calm Mind", "Agility", "Quiver Dance", "Shift Gear" };
        var offensiveCount = pokemonTeam.Count(p => 
            p.Moves.Any(m => setupMoves.Contains(m.Name)) ||
            (p.EVs.Contains("252 Atk") || p.EVs.Contains("252 SpA")) && p.EVs.Contains("252 Spe"));
        
        if (offensiveCount >= 5)
        {
            return ("Hyper Offense", "Aggressive team focused on overwhelming opponents with multiple setup sweepers");
        }
        
        return ("Balanced", "Well-rounded team with mix of offensive and defensive elements");
    }

    private async Task CopyTeam()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", teamInput);
            errorMessage = "";
        }
        catch
        {
            errorMessage = "Failed to copy to clipboard. Please copy manually.";
        }
    }

    private void ClearInput()
    {
        teamInput = "";
        pokemonTeam.Clear();
        errorMessage = "";
    }

    // PokeAPI response classes
    public class PokeApiResponse
    {
        public Sprites? Sprites { get; set; }
        public List<PokemonTypeSlot>? Types { get; set; }
    }

    public class Sprites
    {
        [System.Text.Json.Serialization.JsonPropertyName("front_default")]
        public string? FrontDefault { get; set; }
    }
    
    public class PokemonTypeSlot
    {
        public int Slot { get; set; }
        public PokeApiTypeInfo? Type { get; set; }
    }
    
    public class PokeApiTypeInfo
    {
        public string? Name { get; set; }
    }
    
    public class ItemApiResponse
    {
        public ItemSprites? Sprites { get; set; }
    }
    
    public class ItemSprites
    {
        [System.Text.Json.Serialization.JsonPropertyName("default")]
        public string? Default { get; set; }
    }
    
    public class MoveApiResponse
    {
        public PokeApiTypeInfo? Type { get; set; }
    }
}
