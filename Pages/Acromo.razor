@page "/"
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@using System.Text.RegularExpressions

<PageTitle>Acromo - Teambuilding Helper</PageTitle>
<link rel="stylesheet" href="css/gen5-theme.css" />

<div class="page-header" style="text-align: center; border: none; background: transparent; padding: 2rem 0;">
    <h1><span style="font-size: 3rem;">üî¨</span> Acromo Teambuilding Helper</h1>
    <p>Analyze your Pokemon team with comprehensive competitive insights</p>
</div>

<details class="gen5-info-box">
    <summary class="gen5-summary">
        <span class="gen5-icon">‚ÑπÔ∏è</span>
        About This Tool
        <span class="gen5-arrow">‚ñº</span>
    </summary>
    <div class="gen5-content">
        <h3>What This Tool Does</h3>
        <p>
            This tool analyzes your Pokemon team in Showdown format and provides comprehensive competitive analysis.
            It displays your team with sprites, evaluates type coverage, detects team archetypes, and checks against
            competitive standards for SV OU (Generation 9 Overused tier).
        </p>
        
        <h3>Analysis Criteria</h3>
        <ul>
            <li><strong>Team Archetypes:</strong> Detects Stall, Semi-Stall, Hyper Offense, or Balanced team compositions</li>
            <li><strong>Type Coverage:</strong> Analyzes which types can hit your team for neutral or super effective damage</li>
            <li><strong>Competitive Checklist:</strong> Evaluates 15+ competitive criteria including:
                <ul>
                    <li>Entry hazards (Stealth Rock, Spikes)</li>
                    <li>Hazard removal (Rapid Spin, Defog)</li>
                    <li>Priority moves and fast Pokemon</li>
                    <li>Status immunity and type resistances</li>
                    <li>Pivoting moves and momentum control</li>
                </ul>
            </li>
        </ul>
        
        <h3>Data Sources</h3>
        <ul>
            <li><strong>PokeAPI:</strong> Pokemon sprites, types, and move data</li>
            <li><strong>Pok√©Sprite:</strong> Item sprites (including Gen 8+ items like Heavy-Duty Boots)</li>
        </ul>
    </div>
</details>

<section class="pokepaste-section">
    <!-- New URL Input Section -->
    <div class="input-section url-input-section">
        <h2>üîó Import from Pokepaste</h2>
        <div class="url-input-container">
            <input 
                type="text" 
                class="form-control gen5-input" 
                @bind="pokepasteUrl" 
                placeholder="https://pokepast.es/..." 
                @onkeyup="@(e => e.Key == "Enter" ? FetchTeamFromUrl() : Task.CompletedTask)" />
            <button class="btn btn-primary" @onclick="FetchTeamFromUrl" disabled="@isLoading">
                <span class="btn-icon">üì•</span> Fetch
            </button>
        </div>
    </div>

    <!-- Collapsible Manual Input Section -->
    <details class="gen5-info-box manual-input-details">
        <summary class="gen5-summary">
            <span class="gen5-icon">üìù</span>
            Or Paste Manually
            <span class="gen5-arrow">‚ñº</span>
        </summary>
        <div class="gen5-content">
            <div class="input-section">
                <textarea 
                    class="team-input" 
                    @bind="teamInput" 
                    placeholder="Paste your Pokemon team here...">
                </textarea>
                <div class="input-controls">
                    <button class="btn btn-primary" @onclick="ParseTeam">
                        <span class="btn-icon">‚ö°</span> Parse Team
                    </button>
                    <button class="btn btn-secondary" @onclick="ClearInput">
                        <span class="btn-icon">üóëÔ∏è</span> Clear
                    </button>
                </div>
            </div>
        </div>
    </details>

    @if (isLoading)
    {
        <div class="loading-container">
            <div class="spinner"></div>
            <p>Loading Pokemon data...</p>
        </div>
    }

    @if (pokemonTeam.Any())
    {
        <div class="output-section">
            <div class="output-header">
                <h2>‚ú® Your Team</h2>
                <button class="btn btn-primary btn-sm" @onclick="CopyTeam">
                    <span class="btn-icon">üìã</span> Copy Team
                </button>
            </div>
            
            <div class="pokemon-grid">
                @foreach (var pokemon in pokemonTeam)
                {
                    <div class="pokemon-card">
                        <div class="pokemon-header">
                            <div class="pokemon-sprite-container">
                                @if (!string.IsNullOrEmpty(pokemon.SpriteUrl))
                                {
                                    <img src="@pokemon.SpriteUrl" alt="@pokemon.Name" class="pokemon-sprite" />
                                }
                                else
                                {
                                    <div class="sprite-placeholder">?</div>
                                }
                            </div>
                            <div class="pokemon-title">
                                <h3>
                                    @(!string.IsNullOrEmpty(pokemon.Nickname) ? pokemon.Nickname : pokemon.Name) 
                                    @if (!string.IsNullOrEmpty(pokemon.Nickname))
                                    {
                                        <span style="font-size: 0.8em; color: var(--text-muted);">(@pokemon.Name)</span>
                                    }
                                    @pokemon.Gender
                                </h3>
                                @if (pokemon.Types.Any())
                                {
                                    <div class="pokemon-types">
                                        @foreach (var type in pokemon.Types)
                                        {
                                            <span class="type-badge type-@type.ToLower()">@type</span>
                                        }
                                    </div>
                                    @if (!string.IsNullOrEmpty(pokemon.TeraType))
                                    {
                                        <div class="pokemon-tera-type" style="margin-top: 4px;">
                                            <span class="type-badge type-@pokemon.TeraType.ToLower()" style="font-size: 0.75rem; padding: 2px 8px; opacity: 0.9;">Tera @pokemon.TeraType</span>
                                        </div>
                                    }
                                }
                                @if (!string.IsNullOrEmpty(pokemon.Item))
                                {
                                    <div class="pokemon-item-container">
                                        @if (!string.IsNullOrEmpty(pokemon.ItemSpriteUrl))
                                        {
                                            <img src="@pokemon.ItemSpriteUrl" alt="@pokemon.Item" class="item-sprite" />
                                        }
                                        <p class="pokemon-item">@@ @pokemon.Item</p>
                                    </div>
                                }
                            </div>
                        </div>
                        
                        <div class="pokemon-details">
                            @if (!string.IsNullOrEmpty(pokemon.Ability))
                            {
                                <div class="detail-row">
                                    <span class="detail-label">Ability:</span>
                                    <span class="detail-value">@pokemon.Ability</span>
                                </div>
                            }

                            @if (!string.IsNullOrEmpty(pokemon.Level))
                            {
                                <div class="detail-row">
                                    <span class="detail-label">Level:</span>
                                    <span class="detail-value">@pokemon.Level</span>
                                </div>
                            }
                            
                            @if (!string.IsNullOrEmpty(pokemon.EVs))
                            {
                                <div class="detail-row">
                                    <span class="detail-label">EVs:</span>
                                    <span class="detail-value">@pokemon.EVs</span>
                                </div>
                            }
                            
                            @if (!string.IsNullOrEmpty(pokemon.IVs))
                            {
                                <div class="detail-row">
                                    <span class="detail-label">IVs:</span>
                                    <span class="detail-value">@pokemon.IVs</span>
                                </div>
                            }
                            
                            @if (!string.IsNullOrEmpty(pokemon.Nature))
                            {
                                <div class="detail-row">
                                    <span class="detail-label">Nature:</span>
                                    <span class="detail-value nature">@pokemon.Nature</span>
                                </div>
                            }
                        </div>
                        
                        @if (pokemon.Moves.Any())
                        {
                            <div class="pokemon-moves">
                                <h4>Moves:</h4>
                                <ul class="move-list">
                                    @foreach (var move in pokemon.Moves)
                                    {
                                        <li class="@(string.IsNullOrEmpty(move.Type) ? "" : $"type-border-{move.Type.ToLower()}")">
                                            @move.Name
                                        </li>
                                    }
                                </ul>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
    }

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger">
            ‚ö†Ô∏è @errorMessage
        </div>
    }
    
    @if (pokemonTeam.Any() && typeAnalysis != null)
    {
        <div class="type-analysis-section">
            <h2>üéØ Type Coverage Analysis</h2>
            
            @if (typeAnalysis.NeutralCoverageTypes.Any())
            {
                <div class="analysis-card">
                    <h3>‚úÖ Neutral Coverage Types</h3>
                    <p class="analysis-description">These types can hit all Pokemon on the team for at least neutral damage:</p>
                    <div class="type-badges">
                        @foreach (var type in typeAnalysis.NeutralCoverageTypes)
                        {
                            <span class="type-badge type-@type.ToLower()">@type</span>
                        }
                    </div>
                </div>
            }
            else
            {
                <div class="analysis-card">
                    <h3>‚úÖ Neutral Coverage Types</h3>
                    <p class="analysis-description">No single type can hit all Pokemon for neutral damage.</p>
                </div>
            }
            
            @if (typeAnalysis.SuperEffectiveCoverageTypes.Any())
            {
                <div class="analysis-card">
                    <h3>‚ö° Super Effective Coverage (2+ Pokemon)</h3>
                    <p class="analysis-description">These types can hit 2 or more Pokemon for super effective damage:</p>
                    @foreach (var coverage in typeAnalysis.SuperEffectiveCoverageTypes)
                    {
                        <div class="coverage-item">
                            <span class="type-badge type-@coverage.Type.ToLower()">@coverage.Type</span>
                            <span class="coverage-count">Hits @coverage.Count Pokemon</span>
                            <div class="affected-pokemon">
                                @foreach (var pokemon in coverage.AffectedPokemon)
                                {
                                    <span class="pokemon-name">@pokemon</span>
                                }
                            </div>
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="analysis-card">
                    <h3>‚ö° Super Effective Coverage (2+ Pokemon)</h3>
                    <p class="analysis-description">No type can hit 2 or more Pokemon for super effective damage.</p>
                </div>
            }
            
            @if (typeAnalysis.ImmunityNotes.Any())
            {
                <div class="immunity-section">
                    <h3>üõ°Ô∏è Immunity Considerations</h3>
                    @foreach (var note in typeAnalysis.ImmunityNotes)
                    {
                        <div class="immunity-item">
                            <div class="immunity-icon">‚ÑπÔ∏è</div>
                            <div class="immunity-text">@note</div>
                        </div>
                    }
                </div>
            }
        </div>
    }
    
    @if (pokemonTeam.Any() && teamRating != null)
    {
        <div class="team-rating-section">
            <h2>üìä Team Rating</h2>
            
            <div class="archetype-display">
                <h3>Team Archetype</h3>
                <span class="archetype-badge archetype-@teamRating.Archetype.ToLower()">@teamRating.Archetype</span>
                <p class="archetype-description">@teamRating.ArchetypeDescription</p>
                <p class="archetype-warning">‚ö†Ô∏è Note: Archetype assessment may be imprecise and is subject to changes in the future.</p>
            </div>
            
            <div class="rating-checklist">
                <h3>Competitive Checklist</h3>
                <p class="checklist-intro">Evaluation based on SV OU competitive standards:</p>
                
                @foreach (var check in teamRating.CheckResults)
                {
                    <div class="check-item check-@check.Status.ToLower()">
                        <div class="check-header">
                            <span class="check-icon">@GetCheckIcon(check.Status)</span>
                            <span class="check-name">@check.Name</span>
                            <span class="check-status-badge">@check.Status</span>
                        </div>
                        <p class="check-description">@check.Description</p>
                        @if (!string.IsNullOrEmpty(check.Details))
                        {
                            <p class="check-details">@check.Details</p>
                        }
                    </div>
                }
            </div>
            
            <div class="rating-summary">
                <h3>Overall Score</h3>
                <div class="score-display">
                    <div class="score-circle">
                        <span class="score-value">@teamRating.PassedChecks</span>
                        <span class="score-total">/ @teamRating.TotalChecks</span>
                    </div>
                    <div class="score-grade">
                        <span class="grade-letter">@teamRating.Grade</span>
                        <p class="grade-description">@teamRating.GradeDescription</p>
                    </div>
                </div>
            </div>
        </div>
    }
</section>


@code {
    private string teamInput = "";
    private string pokepasteUrl = "";
    private List<PokemonData> pokemonTeam = new();
    private bool isLoading = false;
    private string errorMessage = "";
    private TypeAnalysis? typeAnalysis = null;
    private TeamRating? teamRating = null;
    private Dictionary<string, string> moveTypeCache = new();

    private class PokemonData
    {
        public string Name { get; set; } = "";
        public string Nickname { get; set; } = "";
        public string Gender { get; set; } = "";
        public string Item { get; set; } = "";
        public string Ability { get; set; } = "";
        public string TeraType { get; set; } = "";
        public string EVs { get; set; } = "";
        public string IVs { get; set; } = "";
        public string Level { get; set; } = "";
        public string Nature { get; set; } = "";

        public List<MoveInfo> Moves { get; set; } = new();
        public string SpriteUrl { get; set; } = "";
        public List<string> Types { get; set; } = new();
        public string ItemSpriteUrl { get; set; } = "";
        
        // Base stats from PokeAPI
        public int BaseHP { get; set; } = 0;
        public int BaseAttack { get; set; } = 0;
        public int BaseDefense { get; set; } = 0;
        public int BaseSpecialAttack { get; set; } = 0;
        public int BaseSpecialDefense { get; set; } = 0;
        public int BaseSpeed { get; set; } = 0;
    }

    private class MoveInfo
    {
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";
    }
    
    private class TeamRating
    {
        public string Archetype { get; set; } = "Balanced";
        public string ArchetypeDescription { get; set; } = "";
        public List<CheckResult> CheckResults { get; set; } = new();
        public int PassedChecks { get; set; }
        public int TotalChecks { get; set; }
        public string Grade { get; set; } = "";
        public string GradeDescription { get; set; } = "";
    }
    
    private class CheckResult
    {
        public string Name { get; set; } = "";
        public string Status { get; set; } = ""; // Pass, Fail, Skip, Warning
        public string Description { get; set; } = "";
        public string Details { get; set; } = "";
    }
    
    private string GetCheckIcon(string status)
    {
        return status switch
        {
            "Pass" => "‚úÖ",
            "Fail" => "‚ùå",
            "Skip" => "‚è≠Ô∏è",
            "Warning" => "‚ö†Ô∏è",
            _ => "‚ùì"
        };
    }
    
    private class TypeAnalysis
    {
        public List<string> NeutralCoverageTypes { get; set; } = new();
        public List<SuperEffectiveCoverage> SuperEffectiveCoverageTypes { get; set; } = new();
        public List<string> ImmunityNotes { get; set; } = new();
    }
    
    private class SuperEffectiveCoverage
    {
        public string Type { get; set; } = "";
        public int Count { get; set; }
        public List<string> AffectedPokemon { get; set; } = new();
    }

    private class AllOriginsResponse
    {
        public string Contents { get; set; } = "";
    }

    private async Task FetchTeamFromUrl()
    {
        if (string.IsNullOrWhiteSpace(pokepasteUrl))
        {
            errorMessage = "Please enter a Pokepaste URL first!";
            return;
        }

        if (!pokepasteUrl.Contains("pokepast.es"))
        {
            errorMessage = "Please enter a valid pokepast.es URL!";
            return;
        }

        errorMessage = "";
        isLoading = true;
        pokemonTeam.Clear();

        try
        {
            // Use AllOrigins as CORS proxy
            var encodedUrl = System.Web.HttpUtility.UrlEncode(pokepasteUrl);
            var proxyUrl = $"https://api.allorigins.win/get?url={encodedUrl}";
            
            var response = await Http.GetFromJsonAsync<AllOriginsResponse>(proxyUrl);
            
            if (response != null && !string.IsNullOrEmpty(response.Contents))
            {
                var htmlContent = response.Contents;
                
                // Parse HTML to find <article> tags and extract text from <pre> tags
                // Regex to find content inside <pre> tags that are likely inside articles
                // Since the structure is simple, we can look for <pre>...</pre> blocks
                
                var matches = Regex.Matches(htmlContent, @"<pre[^>]*>(.*?)</pre>", RegexOptions.Singleline | RegexOptions.IgnoreCase);
                
                if (matches.Count > 0)
                {
                    var extractedTeam = new System.Text.StringBuilder();
                    
                    foreach (Match match in matches)
                    {
                        // Decode HTML entities (like &lt; &gt; etc)
                        var rawText = match.Groups[1].Value;
                        
                        // Remove HTML tags inside pre if any (like spans for colors)
                        var cleanText = Regex.Replace(rawText, @"<[^>]+>", "");
                        
                        // Decode HTML entities
                        cleanText = System.Net.WebUtility.HtmlDecode(cleanText);
                        
                        extractedTeam.AppendLine(cleanText.Trim());
                        extractedTeam.AppendLine(); // Add spacing between mons
                    }
                    
                    teamInput = extractedTeam.ToString().Trim();
                    
                    if (string.IsNullOrWhiteSpace(teamInput))
                    {
                         errorMessage = "Could not extract team data from the URL. Please try pasting manually.";
                    }
                    else
                    {
                        await ParseTeam();
                    }
                }
                else
                {
                    errorMessage = "No Pokemon data found in the URL. Please try pasting manually.";
                }
            }
            else
            {
                errorMessage = "Failed to fetch data from the URL. Please check the link or try pasting manually.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error fetching from URL: {ex.Message}. Please try pasting manually.";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task ParseTeam()
    {
        if (string.IsNullOrWhiteSpace(teamInput))
        {
            errorMessage = "Please paste a Pokemon team first!";
            return;
        }

        errorMessage = "";
        isLoading = true;
        pokemonTeam.Clear();

        try
        {
            var lines = teamInput.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            PokemonData? currentPokemon = null;

            foreach (var line in lines)
            {
                var trimmedLine = line.Trim();
                
                // New Pokemon (first line with name)
                if (!trimmedLine.StartsWith("-") && 
                    !trimmedLine.StartsWith("Ability:") && 
                    !trimmedLine.StartsWith("Tera Type:") &&
                    !trimmedLine.StartsWith("EVs:") &&
                    !trimmedLine.StartsWith("IVs:") &&
                    !trimmedLine.StartsWith("Level:") &&
                    !trimmedLine.Contains("Nature"))
                {
                    if (currentPokemon != null)
                    {
                        pokemonTeam.Add(currentPokemon);
                    }
                    
                    currentPokemon = new PokemonData();
                    
                    // Parse name, gender, and item
                    var parts = trimmedLine.Split('@');
                    var namePart = parts[0].Trim();
                    
                    // Extract gender
                    if (namePart.Contains("(M)"))
                    {
                        currentPokemon.Gender = "‚ôÇ";
                        namePart = namePart.Replace("(M)", "").Trim();
                    }
                    else if (namePart.Contains("(F)"))
                    {
                        currentPokemon.Gender = "‚ôÄ";
                        namePart = namePart.Replace("(F)", "").Trim();
                    }
                    
                    // Handle nicknames: "Nickname (Species)" -> extract "Species"
                    // If the name ends with ')' and has a '(', it likely has a nickname
                    if (namePart.EndsWith(")") && namePart.Contains("("))
                    {
                        int lastOpenParen = namePart.LastIndexOf('(');
                        if (lastOpenParen != -1)
                        {
                            // Extract the text inside the last set of parentheses for the species name
                            var speciesName = namePart.Substring(lastOpenParen + 1, namePart.Length - lastOpenParen - 2).Trim();
                            
                            // The part before the parenthesis is the nickname
                            var nickname = namePart.Substring(0, lastOpenParen).Trim();
                            
                            if (!string.IsNullOrEmpty(speciesName))
                            {
                                currentPokemon.Name = speciesName;
                                currentPokemon.Nickname = nickname;
                            }
                            else
                            {
                                currentPokemon.Name = namePart;
                            }
                        }
                        else
                        {
                            currentPokemon.Name = namePart;
                        }
                    }
                    else
                    {
                        currentPokemon.Name = namePart;
                    }
                    
                    if (parts.Length > 1)
                    {
                        currentPokemon.Item = parts[1].Trim();
                    }
                }
                else if (currentPokemon != null)
                {
                    // Parse other attributes
                    if (trimmedLine.StartsWith("Ability:"))
                    {
                        currentPokemon.Ability = trimmedLine.Replace("Ability:", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("Tera Type:"))
                    {
                        currentPokemon.TeraType = trimmedLine.Replace("Tera Type:", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("EVs:"))
                    {
                        currentPokemon.EVs = trimmedLine.Replace("EVs:", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("IVs:"))
                    {
                        currentPokemon.IVs = trimmedLine.Replace("IVs:", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("Level:"))
                    {
                        currentPokemon.Level = trimmedLine.Replace("Level:", "").Trim();
                    }
                    else if (trimmedLine.Contains("Nature"))
                    {
                        currentPokemon.Nature = trimmedLine.Replace("Nature", "").Trim();
                    }
                    else if (trimmedLine.StartsWith("-"))
                    {
                        var moveName = trimmedLine.Substring(1).Trim();
                        currentPokemon.Moves.Add(new MoveInfo { Name = moveName });
                    }
                }
            }
            
            // Add last Pokemon
            if (currentPokemon != null)
            {
                pokemonTeam.Add(currentPokemon);
            }
            
            // Fetch sprites and data for all pokemon
            foreach (var p in pokemonTeam)
            {
                await FetchPokemonSprite(p);
            }
            
            // Calculate type analysis
            typeAnalysis = CalculateTypeAnalysis();
            
            // Calculate team rating
            teamRating = CalculateTeamRating();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error parsing team: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task FetchPokemonSprite(PokemonData pokemon)
    {
        try
        {
            // Convert Pokemon name to API format (lowercase, replace spaces with hyphens)
            var apiName = pokemon.Name.ToLower()
                .Replace(" ", "-")
                .Replace("'", "")
                .Replace(".", "")
                .Replace(":", "");
            
            var response = await Http.GetFromJsonAsync<PokeApiResponse>($"https://pokeapi.co/api/v2/pokemon/{apiName}");
            
            if (response?.Sprites?.FrontDefault != null)
            {
                pokemon.SpriteUrl = response.Sprites.FrontDefault;
            }
            
            // Fetch types
            if (response?.Types != null)
            {
                pokemon.Types = response.Types.Select(t => t.Type?.Name ?? "").Where(n => !string.IsNullOrEmpty(n)).ToList();
            }
            
            // Fetch base stats
            if (response?.Stats != null)
            {
                foreach (var stat in response.Stats)
                {
                    switch (stat.Stat?.Name)
                    {
                        case "hp": pokemon.BaseHP = stat.BaseStat; break;
                        case "attack": pokemon.BaseAttack = stat.BaseStat; break;
                        case "defense": pokemon.BaseDefense = stat.BaseStat; break;
                        case "special-attack": pokemon.BaseSpecialAttack = stat.BaseStat; break;
                        case "special-defense": pokemon.BaseSpecialDefense = stat.BaseStat; break;
                        case "speed": pokemon.BaseSpeed = stat.BaseStat; break;
                    }
                }
            }
        }
        catch
        {
            // If sprite fetch fails, leave it empty (will show placeholder)
            pokemon.SpriteUrl = "";
        }
        
        // Fetch item sprite if item exists
        if (!string.IsNullOrEmpty(pokemon.Item))
        {
            await FetchItemSprite(pokemon);
        }
        
        // Fetch move types
        foreach (var move in pokemon.Moves)
        {
            await FetchMoveType(move);
        }
        StateHasChanged(); // Ensure UI updates after fetching
    }
    
    private async Task FetchMoveType(MoveInfo move)
    {
        // Check cache first
        if (moveTypeCache.ContainsKey(move.Name.ToLower()))
        {
            move.Type = moveTypeCache[move.Name.ToLower()];
            return;
        }

        try
        {
            // Convert move name to API format
            var apiName = move.Name.ToLower()
                .Replace(" ", "-")
                .Replace("'", "")
                .Replace(".", "")
                .Replace(":", "");
            
            var options = new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };

            var response = await Http.GetFromJsonAsync<MoveApiResponse>($"https://pokeapi.co/api/v2/move/{apiName}", options);
            
            if (response?.Type?.Name != null)
            {
                Console.WriteLine($"Fetched type for {move.Name}: {response.Type.Name}");
                move.Type = response.Type.Name;
                moveTypeCache[move.Name.ToLower()] = move.Type;
            }
            else
            {
                Console.WriteLine($"Failed to fetch type for {move.Name} (Response or Type was null)");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching move type for {move.Name}: {ex.Message}");
        }
    }
    
    private async Task FetchItemSprite(PokemonData pokemon)
    {
        try
        {
            // Convert item name to API format (lowercase, replace spaces with hyphens)
            var apiItemName = pokemon.Item.ToLower()
                .Replace(" ", "-")
                .Replace("'", "")
                .Replace(".", "")
                .Replace(":", "");
            
            // Special case for Booster Energy - use pokepast.es sprite
            if (apiItemName == "booster-energy")
            {
                pokemon.ItemSpriteUrl = "https://pokepast.es/img/items/1880.png";
                return;
            }
            
            // Try PokeAPI first
            try
            {
                var response = await Http.GetFromJsonAsync<ItemApiResponse>($"https://pokeapi.co/api/v2/item/{apiItemName}");
                
                if (response?.Sprites?.Default != null)
                {
                    pokemon.ItemSpriteUrl = response.Sprites.Default;
                    return;
                }
            }
            catch
            {
                // PokeAPI failed, continue to fallbacks
            }
            
            // Fallback 1: Try PokeAPI sprites GitHub directly (works for newer items like Booster Energy)
            try
            {
                var githubUrl = $"https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/{apiItemName}.png";
                var testResponse = await Http.GetAsync(githubUrl);
                if (testResponse.IsSuccessStatusCode)
                {
                    pokemon.ItemSpriteUrl = githubUrl;
                    return;
                }
            }
            catch
            {
                // GitHub sprites failed, continue to next fallback
            }
            
            // Fallback 2: Pok√©Sprite database for items not in PokeAPI
            pokemon.ItemSpriteUrl = $"https://raw.githubusercontent.com/msikma/pokesprite/master/items/hold-item/{apiItemName}.png";
        }
        catch
        {
            // If all fails, leave it empty
            pokemon.ItemSpriteUrl = "";
        }
    }
    
    private int GetEVValue(PokemonData pokemon, string statName)
    {
        if (string.IsNullOrEmpty(pokemon.EVs)) return 0;
        
        var evParts = pokemon.EVs.Split('/');
        foreach (var part in evParts)
        {
            var trimmed = part.Trim();
            // Handle exact matches or contained strings (e.g. "Atk" in "252 Atk")
            // We need to be careful not to match "SpA" when looking for "A" if that was a thing, 
            // but standard notation is HP, Atk, Def, SpA, SpD, Spe.
            if (trimmed.EndsWith($" {statName}") || trimmed == statName)
            {
                var evValueStr = trimmed.Replace(statName, "").Trim();
                if (int.TryParse(evValueStr, out int parsedEv))
                {
                    return parsedEv;
                }
                // If just the stat name is present without number (rare in paste), assume 0 or handle error
                // In Showdown pastes, it's usually "252 Atk"
            }
        }
        return 0;
    }

    private double GetNatureModifier(string nature, string statName)
    {
        if (string.IsNullOrEmpty(nature)) return 1.0;
        
        // Map of Nature -> (Boosted, Hindered)
        var natureMap = new Dictionary<string, (string, string)>
        {
            { "Adamant", ("Atk", "SpA") }, { "Bashful", ("", "") }, { "Bold", ("Def", "Atk") },
            { "Brave", ("Atk", "Spe") }, { "Calm", ("SpD", "Atk") }, { "Careful", ("SpD", "SpA") },
            { "Docile", ("", "") }, { "Gentle", ("SpD", "Def") }, { "Hardy", ("", "") },
            { "Hasty", ("Spe", "Def") }, { "Impish", ("Def", "SpA") }, { "Jolly", ("Spe", "SpA") },
            { "Lax", ("Def", "SpD") }, { "Lonely", ("Atk", "Def") }, { "Mild", ("SpA", "Def") },
            { "Modest", ("SpA", "Atk") }, { "Naive", ("Spe", "SpD") }, { "Naughty", ("Atk", "SpD") },
            { "Quiet", ("SpA", "Spe") }, { "Quirky", ("", "") }, { "Rash", ("SpA", "SpD") },
            { "Relaxed", ("Def", "Spe") }, { "Sassy", ("SpD", "Spe") }, { "Serious", ("", "") },
            { "Timid", ("Spe", "Atk") }
        };

        if (natureMap.TryGetValue(nature, out var modifiers))
        {
            if (modifiers.Item1 == statName) return 1.1;
            if (modifiers.Item2 == statName) return 0.9;
        }
        
        return 1.0;
    }

    private int CalculateStat(PokemonData pokemon, string statName, int baseStat)
    {
        // Pokemon stat formula
        int level = 100;
        if (!string.IsNullOrEmpty(pokemon.Level) && int.TryParse(pokemon.Level, out int parsedLevel)) level = parsedLevel;
        
        int iv = 31; // Default to max IVs
        // We could parse IVs here if needed, similar to EVs
        
        int ev = GetEVValue(pokemon, statName);
        
        if (statName == "HP")
        {
            if (baseStat == 1) return 1; // Shedinja case
            return ((2 * baseStat + iv + (ev / 4)) * level / 100) + level + 10;
        }
        
        double natureMod = GetNatureModifier(pokemon.Nature, statName);
        int baseCalc = ((2 * baseStat + iv + (ev / 4)) * level / 100) + 5;
        return (int)(baseCalc * natureMod);
    }

    private int CalculateFinalSpeed(PokemonData pokemon)
    {
        return CalculateStat(pokemon, "Spe", pokemon.BaseSpeed);
    }
    
    private TypeAnalysis CalculateTypeAnalysis()
    {
        var analysis = new TypeAnalysis();
        var allTypes = new[] { "Normal", "Fire", "Water", "Electric", "Grass", "Ice", "Fighting", "Poison", 
                               "Ground", "Flying", "Psychic", "Bug", "Rock", "Ghost", "Dragon", "Dark", "Steel", "Fairy" };
        
        // Abilities that grant immunities
        var immunityAbilities = new Dictionary<string, string[]>
        {
            { "Flash Fire", new[] { "fire" } },
            { "Water Absorb", new[] { "water" } },
            { "Dry Skin", new[] { "water" } },
            { "Storm Drain", new[] { "water" } },
            { "Sap Sipper", new[] { "grass" } },
            { "Levitate", new[] { "ground" } },
            { "Volt Absorb", new[] { "electric" } },
            { "Lightning Rod", new[] { "electric" } },
            { "Motor Drive", new[] { "electric" } },
            { "Good as Gold", new[] { "status" } }, // Immune to status moves
            { "Thick Fat", new string[] { } }, // Reduces damage but doesn't grant immunity
            { "Wonder Guard", new string[] { } }, // Special case
        };
        
        // Items that grant immunities
        var immunityItems = new Dictionary<string, string[]>
        {
            { "Air Balloon", new[] { "ground" } },
            { "Heavy-Duty Boots", new string[] { } }, // Entry hazards, not type immunity
        };
        
        foreach (var attackType in allTypes)
        {
            int neutralCount = 0;
            int superEffectiveCount = 0;
            var affectedBySuper = new List<string>();
            
            foreach (var pokemon in pokemonTeam)
            {
                var effectiveness = GetTypeEffectiveness(attackType.ToLower(), pokemon, immunityAbilities, immunityItems);
                
                if (effectiveness >= 1.0) neutralCount++;
                if (effectiveness > 1.0)
                {
                    superEffectiveCount++;
                    affectedBySuper.Add(pokemon.Name);
                }
            }
            
            // Check for neutral coverage (hits all Pokemon for at least neutral damage)
            if (neutralCount == pokemonTeam.Count)
            {
                analysis.NeutralCoverageTypes.Add(attackType);
            }
            
            // Check for super effective coverage (hits 2+ Pokemon for super effective damage)
            if (superEffectiveCount >= 2)
            {
                analysis.SuperEffectiveCoverageTypes.Add(new SuperEffectiveCoverage
                {
                    Type = attackType,
                    Count = superEffectiveCount,
                    AffectedPokemon = affectedBySuper
                });
            }
        }
        
        // Sort super effective coverage by count (descending)
        analysis.SuperEffectiveCoverageTypes = analysis.SuperEffectiveCoverageTypes
            .OrderByDescending(c => c.Count)
            .ToList();
        
        // Add immunity notes
        foreach (var pokemon in pokemonTeam)
        {
            if (!string.IsNullOrEmpty(pokemon.Ability))
            {
                if (immunityAbilities.ContainsKey(pokemon.Ability))
                {
                    var immuneTypes = immunityAbilities[pokemon.Ability];
                    if (immuneTypes.Any())
                    {
                        analysis.ImmunityNotes.Add($"{pokemon.Name} with {pokemon.Ability} is immune to {string.Join(", ", immuneTypes)} type moves");
                    }
                }
            }
            
            if (!string.IsNullOrEmpty(pokemon.Item))
            {
                if (immunityItems.ContainsKey(pokemon.Item))
                {
                    var immuneTypes = immunityItems[pokemon.Item];
                    if (immuneTypes.Any())
                    {
                        analysis.ImmunityNotes.Add($"{pokemon.Name} holding {pokemon.Item} is immune to {string.Join(", ", immuneTypes)} type moves");
                    }
                }
            }
        }
        
        return analysis;
    }
    
    private double GetTypeEffectiveness(string attackType, PokemonData pokemon, 
        Dictionary<string, string[]> immunityAbilities, Dictionary<string, string[]> immunityItems)
    {
        // Check for ability immunity
        if (!string.IsNullOrEmpty(pokemon.Ability) && immunityAbilities.ContainsKey(pokemon.Ability))
        {
            if (immunityAbilities[pokemon.Ability].Contains(attackType))
                return 0.0;
        }
        
        // Check for item immunity
        if (!string.IsNullOrEmpty(pokemon.Item) && immunityItems.ContainsKey(pokemon.Item))
        {
            if (immunityItems[pokemon.Item].Contains(attackType))
                return 0.0;
        }
        
        // Calculate base type effectiveness
        double effectiveness = 1.0;
        
        foreach (var defenderType in pokemon.Types)
        {
            effectiveness *= GetSingleTypeEffectiveness(attackType, defenderType);
        }
        
        return effectiveness;
    }
    
    private double GetSingleTypeEffectiveness(string attackType, string defenderType)
    {
        // Type effectiveness chart
        var typeChart = new Dictionary<string, Dictionary<string, double>>
        {
            ["normal"] = new() { ["rock"] = 0.5, ["ghost"] = 0.0, ["steel"] = 0.5 },
            ["fire"] = new() { ["fire"] = 0.5, ["water"] = 0.5, ["grass"] = 2.0, ["ice"] = 2.0, ["bug"] = 2.0, ["rock"] = 0.5, ["dragon"] = 0.5, ["steel"] = 2.0 },
            ["water"] = new() { ["fire"] = 2.0, ["water"] = 0.5, ["grass"] = 0.5, ["ground"] = 2.0, ["rock"] = 2.0, ["dragon"] = 0.5 },
            ["electric"] = new() { ["water"] = 2.0, ["electric"] = 0.5, ["grass"] = 0.5, ["ground"] = 0.0, ["flying"] = 2.0, ["dragon"] = 0.5 },
            ["grass"] = new() { ["fire"] = 0.5, ["water"] = 2.0, ["grass"] = 0.5, ["poison"] = 0.5, ["ground"] = 2.0, ["flying"] = 0.5, ["bug"] = 0.5, ["rock"] = 2.0, ["dragon"] = 0.5, ["steel"] = 0.5 },
            ["ice"] = new() { ["fire"] = 0.5, ["water"] = 0.5, ["grass"] = 2.0, ["ice"] = 0.5, ["ground"] = 2.0, ["flying"] = 2.0, ["dragon"] = 2.0, ["steel"] = 0.5 },
            ["fighting"] = new() { ["normal"] = 2.0, ["ice"] = 2.0, ["poison"] = 0.5, ["flying"] = 0.5, ["psychic"] = 0.5, ["bug"] = 0.5, ["rock"] = 2.0, ["ghost"] = 0.0, ["dark"] = 2.0, ["steel"] = 2.0, ["fairy"] = 0.5 },
            ["poison"] = new() { ["grass"] = 2.0, ["poison"] = 0.5, ["ground"] = 0.5, ["rock"] = 0.5, ["ghost"] = 0.5, ["steel"] = 0.0, ["fairy"] = 2.0 },
            ["ground"] = new() { ["fire"] = 2.0, ["electric"] = 2.0, ["grass"] = 0.5, ["poison"] = 2.0, ["flying"] = 0.0, ["bug"] = 0.5, ["rock"] = 2.0, ["steel"] = 2.0 },
            ["flying"] = new() { ["electric"] = 0.5, ["grass"] = 2.0, ["fighting"] = 2.0, ["bug"] = 2.0, ["rock"] = 0.5, ["steel"] = 0.5 },
            ["psychic"] = new() { ["fighting"] = 2.0, ["poison"] = 2.0, ["psychic"] = 0.5, ["dark"] = 0.0, ["steel"] = 0.5 },
            ["bug"] = new() { ["fire"] = 0.5, ["grass"] = 2.0, ["fighting"] = 0.5, ["poison"] = 0.5, ["flying"] = 0.5, ["psychic"] = 2.0, ["ghost"] = 0.5, ["dark"] = 2.0, ["steel"] = 0.5, ["fairy"] = 0.5 },
            ["rock"] = new() { ["fire"] = 2.0, ["ice"] = 2.0, ["fighting"] = 0.5, ["ground"] = 0.5, ["flying"] = 2.0, ["bug"] = 2.0, ["steel"] = 0.5 },
            ["ghost"] = new() { ["normal"] = 0.0, ["psychic"] = 2.0, ["ghost"] = 2.0, ["dark"] = 0.5 },
            ["dragon"] = new() { ["dragon"] = 2.0, ["steel"] = 0.5, ["fairy"] = 0.0 },
            ["dark"] = new() { ["fighting"] = 0.5, ["psychic"] = 2.0, ["ghost"] = 2.0, ["dark"] = 0.5, ["fairy"] = 0.5 },
            ["steel"] = new() { ["fire"] = 0.5, ["water"] = 0.5, ["electric"] = 0.5, ["ice"] = 2.0, ["rock"] = 2.0, ["steel"] = 0.5, ["fairy"] = 2.0 },
            ["fairy"] = new() { ["fire"] = 0.5, ["fighting"] = 2.0, ["poison"] = 0.5, ["dragon"] = 2.0, ["dark"] = 2.0, ["steel"] = 0.5 }
        };
        
        if (typeChart.ContainsKey(attackType) && typeChart[attackType].ContainsKey(defenderType))
        {
            return typeChart[attackType][defenderType];
        }
        
        return 1.0; // Neutral effectiveness
    }
    
    private TeamRating CalculateTeamRating()
    {
        var rating = new TeamRating();
        var checks = new List<CheckResult>();
        
        // Detect team archetype
        var (archetype, description) = DetectArchetype();
        rating.Archetype = archetype;
        rating.ArchetypeDescription = description;
        
        bool isStall = archetype == "Stall";
        bool isSemiStall = archetype == "Semi-Stall";
        bool isHO = archetype == "Hyper Offense";
        
        // Priority moves list
        var priorityMoves = new[] { "Extreme Speed", "Sucker Punch", "Shadow Sneak", "Aqua Jet", "Ice Shard",
            "Mach Punch", "Bullet Punch", "Vacuum Wave", "Water Shuriken", "Accelerock", "Quick Attack",
            "First Impression", "Jet Punch", "Aqua Step", "Grassy Glide", "Fake Out", "Thunderclap" };
        
        // 1. Priority Move Check
        if (!isStall && !isSemiStall)
        {
            var priorityUsers = pokemonTeam
                .Where(p => p.Moves.Any(m => priorityMoves.Contains(m.Name)))
                .Select(p => new { 
                    Pokemon = p.Name, 
                    Moves = p.Moves.Where(m => priorityMoves.Contains(m.Name)).Select(m => m.Name).ToList() 
                })
                .ToList();
            
            var hasPriority = priorityUsers.Any();
            var detailsText = hasPriority 
                ? $"Found: {string.Join(", ", priorityUsers.Select(pu => $"{pu.Pokemon} ({string.Join(", ", pu.Moves)})"))}" 
                : "No priority moves found. Consider adding Extreme Speed, Sucker Punch, or Aqua Jet";
            
            checks.Add(new CheckResult
            {
                Name = "Priority Move",
                Status = hasPriority ? "Pass" : "Fail",
                Description = "Preferable to have at least one Pokemon with a priority move",
                Details = detailsText
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Priority Move", Status = "Skip", Description = $"{archetype} teams don't require priority moves" });
        }
        
        // 2. Fast Pokemon Check (350+ calculated speed)
        if (!isStall && !isSemiStall)
        {
            var hasFastMon = pokemonTeam.Any(p => CalculateFinalSpeed(p) >= 350);
            var fastestSpeed = pokemonTeam.Any() ? pokemonTeam.Max(p => CalculateFinalSpeed(p)) : 0;
            checks.Add(new CheckResult
            {
                Name = "Fast Pokemon",
                Status = hasFastMon ? "Pass" : "Warning",
                Description = "Nice to have a Pokemon with 350+ speed",
                Details = hasFastMon ? $"Found Pokemon with {fastestSpeed} speed" : $"Fastest Pokemon has {fastestSpeed} speed - consider adding a faster Pokemon"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Fast Pokemon", Status = "Skip", Description = $"{archetype} teams don't require fast Pokemon" });
        }
        
        // 3. Hazards Check
        var hasRocks = pokemonTeam.Any(p => p.Moves.Any(m => m.Name == "Stealth Rock"));
        var hasSpikes = pokemonTeam.Any(p => p.Moves.Any(m => m.Name == "Spikes"));
        var hasStickyWeb = pokemonTeam.Any(p => p.Moves.Any(m => m.Name == "Sticky Web"));
        var hasScreens = pokemonTeam.Any(p => p.Moves.Any(m => m.Name.Contains("Light Screen") || m.Name.Contains("Reflect") || m.Name.Contains("Aurora Veil")));
        
        if (hasStickyWeb || hasScreens)
        {
            checks.Add(new CheckResult
            {
                Name = "Entry Hazards",
                Status = "Pass",
                Description = "Sticky Web or Screens team detected",
                Details = hasStickyWeb ? "Sticky Web team" : "Screens HO team"
            });
        }
        else
        {
            checks.Add(new CheckResult
            {
                Name = "Entry Hazards",
                Status = hasRocks ? "Pass" : "Fail",
                Description = "Team needs Stealth Rock (Spikes optional)",
                Details = hasRocks ? (hasSpikes ? "Has Stealth Rock and Spikes" : "Has Stealth Rock") : "Missing Stealth Rock - critical for chip damage"
            });
        }
        
        // 4. Hazard Control Check
        var hazardRemovalMoves = new[] { "Rapid Spin", "Defog", "Mortal Spin", "Tidy Up", "Court Change" };
        var hasRemovalMove = pokemonTeam.Any(p => p.Moves.Any(m => hazardRemovalMoves.Contains(m.Name)));
        var hasMagicBounce = pokemonTeam.Any(p => p.Ability == "Magic Bounce");
        var hasHazardControl = hasRemovalMove || hasMagicBounce;
        var heavyBootsCount = pokemonTeam.Count(p => p.Item.Contains("Heavy-Duty Boots"));
        
        if (!isHO && heavyBootsCount < 3)
        {
            checks.Add(new CheckResult
            {
                Name = "Hazard Control",
                Status = hasHazardControl ? "Pass" : "Fail",
                Description = "Team needs hazard removal or Magic Bounce unless HO or 3+ Heavy-Duty Boots",
                Details = hasHazardControl ? (hasRemovalMove ? "Has hazard removal move" : "Has Magic Bounce user") : $"No hazard removal and only {heavyBootsCount} Heavy-Duty Boots"
            });
        }
        else
        {
            checks.Add(new CheckResult
            {
                Name = "Hazard Control",
                Status = "Skip",
                Description = isHO ? "Hyper Offense teams don't require hazard control" : $"Team has {heavyBootsCount} Heavy-Duty Boots"
            });
        }
        
        // 5. Toxic Spikes Absorber
        var poisonGrounded = pokemonTeam.Count(p => 
            p.Types.Contains("poison") && 
            !p.Types.Contains("flying") && 
            p.Ability != "Levitate" && 
            !p.Item.Contains("Air Balloon"));
        var steelCount = pokemonTeam.Count(p => p.Types.Contains("steel"));
        var flyingCount = pokemonTeam.Count(p => p.Types.Contains("flying"));
        
        if (isHO || heavyBootsCount >= 3 || steelCount + flyingCount >= 3)
        {
            // Build specific message based on what the team has
            string skipReason;
            if (isHO)
            {
                skipReason = "Hyper Offense teams don't require hazard control";
            }
            else if (heavyBootsCount >= 3 && steelCount + flyingCount >= 3)
            {
                skipReason = $"Team has {heavyBootsCount} Heavy-Duty Boots and {steelCount + flyingCount} Steel or Flying types";
            }
            else if (heavyBootsCount >= 3)
            {
                skipReason = $"Team has {heavyBootsCount} Heavy-Duty Boots";
            }
            else
            {
                skipReason = $"Team has {steelCount + flyingCount} Steel or Flying types";
            }
            
            checks.Add(new CheckResult
            {
                Name = "Toxic Spikes Absorber",
                Status = "Skip",
                Description = skipReason
            });
        }
        else
        {
            checks.Add(new CheckResult
            {
                Name = "Toxic Spikes Absorber",
                Status = poisonGrounded > 0 ? "Pass" : "Warning",
                Description = "Team needs a grounded Poison-type to absorb Toxic Spikes",
                Details = poisonGrounded > 0 ? $"Has {poisonGrounded} grounded Poison-type(s)" : "No grounded Poison-type found"
            });
        }
        
        // 6. Status Immunity
        var hasGroundElectric = pokemonTeam.Any(p => p.Types.Contains("ground") || p.Types.Contains("electric"));
        var hasFire = pokemonTeam.Any(p => p.Types.Contains("fire"));
        var hasSteelPoison = pokemonTeam.Any(p => p.Types.Contains("steel") || p.Types.Contains("poison"));
        var hasSpecialAbility = pokemonTeam.Any(p => new[] { "Magic Guard", "Poison Heal", "Purifying Salt", "Good as Gold" }.Contains(p.Ability));
        
        var statusImmunities = new List<string>();
        if (hasGroundElectric) statusImmunities.Add("Thunder Wave");
        if (hasFire) statusImmunities.Add("Burn");
        if (hasSteelPoison) statusImmunities.Add("Toxic");
        if (hasSpecialAbility) statusImmunities.Add("Multiple");
        
        checks.Add(new CheckResult
        {
            Name = "Status Immunity",
            Status = statusImmunities.Count >= 2 ? "Pass" : "Warning",
            Description = "Preferable to have immunity to major status conditions",
            Details = statusImmunities.Any() ? $"Immune to: {string.Join(", ", statusImmunities)}" : "No status immunities found"
        });
        
        // 7. Type Resistance (for non-HO)
        if (!isHO)
        {
            var allTypes = new[] { "normal", "fire", "water", "electric", "grass", "ice", "fighting", "poison",
                "ground", "flying", "psychic", "bug", "rock", "ghost", "dragon", "dark", "steel", "fairy" };
            var resistedTypes = 0;
            
            foreach (var type in allTypes)
            {
                foreach (var pokemon in pokemonTeam)
                {
                    var effectiveness = 1.0;
                    foreach (var defType in pokemon.Types)
                    {
                        effectiveness *= GetSingleTypeEffectiveness(type, defType);
                    }
                    if (effectiveness < 1.0)
                    {
                        resistedTypes++;
                        break;
                    }
                }
            }
            
            checks.Add(new CheckResult
            {
                Name = "Type Resistance",
                Status = resistedTypes == 18 ? "Pass" : "Warning",
                Description = "Preferable for team to resist all 18 types",
                Details = $"Resists {resistedTypes}/18 types"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Type Resistance", Status = "Skip", Description = "HO teams don't require full type coverage" });
        }
        
        // 8. Steel Type
        if (!isStall && !isHO)
        {
            checks.Add(new CheckResult
            {
                Name = "Steel Type",
                Status = steelCount > 0 ? "Pass" : "Warning",
                Description = "Having a Steel-type is highly recommended",
                Details = steelCount > 0 ? $"Has {steelCount} Steel-type(s)" : "No Steel-type found - consider adding one for defensive utility"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Steel Type", Status = "Skip", Description = $"{archetype} teams don't require Steel-types" });
        }
        
        // 9. Ground Immunity
        var hasGroundImmunity = pokemonTeam.Any(p => 
            p.Ability == "Levitate" || 
            p.Types.Contains("flying") || 
            p.Item.Contains("Air Balloon") ||
            p.Ability == "Grassy Surge");
        
        checks.Add(new CheckResult
        {
            Name = "Ground Immunity",
            Status = hasGroundImmunity ? "Pass" : "Warning",
            Description = "Nice to have Ground immunity (Levitate/Flying/Air Balloon) or a Grassy Surge pokemon",
            Details = hasGroundImmunity ? "Has Ground immunity" : "No Ground immunity found"
        });
        
        // 10. Electric Immunity
        if (!isHO)
        {
            var hasElectricImmunity = pokemonTeam.Any(p => 
                p.Types.Contains("ground") || 
                p.Ability == "Lightning Rod" || 
                p.Ability == "Volt Absorb");
            
            checks.Add(new CheckResult
            {
                Name = "Electric Immunity",
                Status = hasElectricImmunity ? "Pass" : "Warning",
                Description = "Nice to have Electric immunity (Ground-type/Lightning Rod/Volt Absorb)",
                Details = hasElectricImmunity ? "Has Electric immunity" : "No Electric immunity found"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Electric Immunity", Status = "Skip", Description = "HO teams don't require Electric immunity" });
        }
        
        // 11. Pivoting Moves
        if (!isStall && !isHO)
        {
            var pivotMoves = new[] { "U-turn", "Volt Switch", "Flip Turn", "Parting Shot", "Teleport", "Chilling Reception" };
            var hasPivot = pokemonTeam.Any(p => p.Moves.Any(m => pivotMoves.Contains(m.Name)));
            
            checks.Add(new CheckResult
            {
                Name = "Pivoting Moves",
                Status = hasPivot ? "Pass" : "Warning",
                Description = "Recommended to have pivoting moves for momentum",
                Details = hasPivot ? "Has pivoting moves" : "No pivoting moves found - consider U-turn or Volt Switch"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Pivoting Moves", Status = "Skip", Description = $"{archetype} teams don't require pivoting moves" });
        }
        
        // 12. Knock Off User
        if (!isHO)
        {
            var hasKnockOff = pokemonTeam.Any(p => p.Moves.Any(m => m.Name == "Knock Off"));
            checks.Add(new CheckResult
            {
                Name = "Knock Off User",
                Status = hasKnockOff ? "Pass" : "Warning",
                Description = "Preferable to have Knock Off for item removal",
                Details = hasKnockOff ? "Has Knock Off" : "No Knock Off found"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Knock Off User", Status = "Skip", Description = "HO teams don't require Knock Off" });
        }
        
        // 13. Knock Off Absorber
        var knockOffAbsorbers = new[] { "Corviknight", "Gliscor", "Clefable", "Great Tusk", "Alomomola", "Landorus-Therian", "Zapdos" };
        var hasKnockOffAbsorber = pokemonTeam.Any(p => 
            p.Ability == "Sticky Hold" || 
            knockOffAbsorbers.Contains(p.Name) ||
            p.Item.Contains("Booster Energy"));
        
        checks.Add(new CheckResult
        {
            Name = "Knock Off Absorber",
            Status = hasKnockOffAbsorber ? "Pass" : "Warning",
            Description = "Nice to have a Knock Off absorber",
            Details = hasKnockOffAbsorber ? "Has Knock Off absorber" : "No Knock Off absorber found"
        });
        
        // 14. Contact Punisher
        if (!isStall && !isHO)
        {
            var hasContactPunisher = pokemonTeam.Any(p => 
                new[] { "Static", "Flame Body", "Rough Skin" }.Contains(p.Ability) ||
                p.Item.Contains("Rocky Helmet"));
            
            checks.Add(new CheckResult
            {
                Name = "Contact Punisher",
                Status = hasContactPunisher ? "Pass" : "Warning",
                Description = "Recommended to have contact punishment (Static/Flame Body/Rough Skin/Rocky Helmet)",
                Details = hasContactPunisher ? "Has contact punisher" : "No contact punisher found"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Contact Punisher", Status = "Skip", Description = $"{archetype} teams don't require contact punishers" });
        }
        
        // 15. Physical and Special Attackers
        if (!isStall && !isSemiStall)
        {
            var hasPhysical = pokemonTeam.Any(p => p.EVs.Contains("252 Atk"));
            var hasSpecial = pokemonTeam.Any(p => p.EVs.Contains("252 SpA"));
            
            checks.Add(new CheckResult
            {
                Name = "Mixed Offense",
                Status = (hasPhysical && hasSpecial) ? "Pass" : "Warning",
                Description = "Preferable to have both physical and special attackers",
                Details = $"Physical: {(hasPhysical ? "Yes" : "No")}, Special: {(hasSpecial ? "Yes" : "No")}"
            });
        }
        else
        {
            checks.Add(new CheckResult { Name = "Mixed Offense", Status = "Skip", Description = $"{archetype} teams don't require mixed offense" });
        }
        
        rating.CheckResults = checks;
        rating.PassedChecks = checks.Count(c => c.Status == "Pass");
        rating.TotalChecks = checks.Count(c => c.Status != "Skip");
        
        // Calculate grade
        var passRate = rating.TotalChecks > 0 ? (double)rating.PassedChecks / rating.TotalChecks : 0;
        if (passRate >= 0.9) { rating.Grade = "S"; rating.GradeDescription = "Excellent - Competitive ready!"; }
        else if (passRate >= 0.8) { rating.Grade = "A"; rating.GradeDescription = "Great - Minor improvements needed"; }
        else if (passRate >= 0.7) { rating.Grade = "B"; rating.GradeDescription = "Good - Some weaknesses to address"; }
        else if (passRate >= 0.6) { rating.Grade = "C"; rating.GradeDescription = "Average - Needs significant work"; }
        else { rating.Grade = "D"; rating.GradeDescription = "Poor - Major issues to fix"; }
        
        return rating;
    }
    
    private (string archetype, string description) DetectArchetype()
    {
        // Define move and ability categories
        var defensiveAbilities = new[] { "Unaware", "Regenerator", "Natural Cure", "Poison Heal", "Pressure", "Magic Bounce" };
        var defensiveMoves = new[] { "Rest", "Recover", "Roost", "Soft-Boiled", "Wish", "Slack Off" };
        var setupMoves = new[] { "Swords Dance", "Dragon Dance", "Nasty Plot", "Calm Mind", "Agility", "Quiver Dance", "Shift Gear" };
        var pivotMoves = new[] { "U-turn", "Volt Switch", "Flip Turn", "Parting Shot", "Teleport", "Chilly Reception" };
        var progressMoves = new[] { "U-turn", "Volt Switch", "Flip Turn", "Knock Off", "Taunt", "Parting Shot" };
        
        // Count bulky Pokemon WITH recovery
        var bulkyWithRecovery = pokemonTeam.Count(p => 
            (defensiveAbilities.Contains(p.Ability) ||
             (p.EVs.Contains("252 HP") && (p.EVs.Contains("252 Def") || p.EVs.Contains("252 SpD")))) &&
            p.Moves.Any(m => defensiveMoves.Contains(m.Name)));
        
        // Count bulky Pokemon (without recovery requirement)
        var bulkyCount = pokemonTeam.Count(p => 
            defensiveAbilities.Contains(p.Ability) ||
            (p.EVs.Contains("252 HP") && (p.EVs.Contains("252 Def") || p.EVs.Contains("252 SpD"))));
        
        // Count offensive threats (using base stats + EV investment)
        var offensiveCount = pokemonTeam.Count(p => 
        {
            // Has setup move
            if (p.Moves.Any(m => setupMoves.Contains(m.Name)))
                return true;
            
            // Has high final attack or special attack (>= 300)
            int finalAtk = CalculateStat(p, "Atk", p.BaseAttack);
            int finalSpA = CalculateStat(p, "SpA", p.BaseSpecialAttack);
            bool hasHighOffense = finalAtk >= 300 || finalSpA >= 300;
            
            // Body Press users with high defense investment (>= 160 EVs)
            bool hasBodyPress = p.Moves.Any(m => m.Name == "Body Press") && GetEVValue(p, "Def") >= 160;
            
            // Weakness Policy users are offensive threats (designed for offensive power)
            bool hasWeaknessPolicy = p.Item.Contains("Weakness Policy");
            
            return hasHighOffense || hasBodyPress || hasWeaknessPolicy;
        });
        
        // Count Pokemon with bulk but no recovery
        var bulkWithoutRecovery = pokemonTeam.Count(p =>
            (p.EVs.Contains("HP") || p.EVs.Contains("Def") || p.EVs.Contains("SpD")) &&
            !p.Moves.Any(m => defensiveMoves.Contains(m.Name)));
        
        // Count breakers (Choice items, Life Orb, Assault Vest)
        var breakerCount = pokemonTeam.Count(p =>
            p.Item.Contains("Choice Band") || p.Item.Contains("Choice Specs") || 
            p.Item.Contains("Life Orb") || p.Item.Contains("Assault Vest"));
        
        // Count pivot users
        var pivotCount = pokemonTeam.Count(p =>
            p.Moves.Any(m => pivotMoves.Contains(m.Name)));
        
        // Count utility breakers
        var semiStallBreakerCount = pokemonTeam.Count(p =>
            p.Moves.Any(m => progressMoves.Contains(m.Name)));
        
        // 1. Detect Pure Stall (all 6 Pokemon are bulky with recovery)
        if (bulkyWithRecovery >= 6)
        {
            return ("Stall", "Defensive team focused on outlasting opponents with entry hazards and recovery");
        }
        
        // 2. Detect Semi-Stall (4-5 bulky with recovery + utility breakers)
        if (bulkyWithRecovery >= 4 && bulkyWithRecovery <= 5 && semiStallBreakerCount >= 1)
        {
            return ("Semi-Stall", "Defensive core with utility breakers that force progress through pivoting, item removal, and disruption");
        }
        
        // 3. Detect Hyper Offense (5+ setup sweepers or max speed offensive Pokemon)
        var hyperOffensiveCount = pokemonTeam.Count(p => 
            p.Moves.Any(m => setupMoves.Contains(m.Name)) ||
            ((p.EVs.Contains("252 Atk") || p.EVs.Contains("252 SpA")) && p.EVs.Contains("252 Spe")));
        
        if (hyperOffensiveCount >= 5)
        {
            return ("Hyper Offense", "Aggressive team focused on overwhelming opponents with multiple setup sweepers");
        }
        
        // 4. Detect Bulky Balance (3-5 bulky + offensive threats, no recovery requirement)
        if (bulkyCount >= 3 && bulkyCount <= 5 && offensiveCount >= 2)
        {
            return ("Bulky Balance", "Defensive core with offensive threats that can break through opponents while maintaining bulk");
        }
        
        // 5. Detect Bulky Offense (2-4 bulk without recovery + 3+ breakers)
        if (bulkWithoutRecovery >= 2 && bulkWithoutRecovery <= 4 && breakerCount >= 3)
        {
            return ("Bulky Offense", "Temporary defensive cores without recovery, relying on powerful breakers to overwhelm opponents");
        }
        
        // 6. Detect Offense (4-5 fast Pokemon + some defense + pivots)
        var fastCount = pokemonTeam.Count(p => p.EVs.Contains("252 Spe") || p.EVs.Contains("Spe"));
        var defensiveCount = pokemonTeam.Count(p => 
            (p.EVs.Contains("HP") || p.EVs.Contains("Def") || p.EVs.Contains("SpD")) &&
            !p.Moves.Any(m => defensiveMoves.Contains(m.Name)));
        
        if (fastCount >= 4 && defensiveCount >= 1 && defensiveCount <= 2 && pivotCount >= 2)
        {
            return ("Offense", "Fast-paced team with synergy and switching in mind, featuring minimal but strategic defensive presence");
        }
        
        return ("Balanced", "Well-rounded team with mix of offensive and defensive elements");
    }

    private async Task CopyTeam()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", teamInput);
            errorMessage = "";
        }
        catch
        {
            errorMessage = "Failed to copy to clipboard. Please copy manually.";
        }
    }

    private void ClearInput()
    {
        teamInput = "";
        pokemonTeam.Clear();
        errorMessage = "";
    }

    // PokeAPI response classes
    public class PokeApiResponse
    {
        public Sprites? Sprites { get; set; }
        public List<PokemonTypeSlot>? Types { get; set; }
        public List<PokemonStat>? Stats { get; set; }
    }

    public class Sprites
    {
        [System.Text.Json.Serialization.JsonPropertyName("front_default")]
        public string? FrontDefault { get; set; }
    }
    
    public class PokemonTypeSlot
    {
        public int Slot { get; set; }
        public PokeApiTypeInfo? Type { get; set; }
    }
    
    public class PokeApiTypeInfo
    {
        public string? Name { get; set; }
    }
    
    public class ItemApiResponse
    {
        public ItemSprites? Sprites { get; set; }
    }
    
    public class ItemSprites
    {
        [System.Text.Json.Serialization.JsonPropertyName("default")]
        public string? Default { get; set; }
    }
    
    public class MoveApiResponse
    {
        public PokeApiTypeInfo? Type { get; set; }
    }
    
    public class PokemonStat
    {
        [System.Text.Json.Serialization.JsonPropertyName("base_stat")]
        public int BaseStat { get; set; }
        public StatInfo? Stat { get; set; }
    }
    
    public class StatInfo
    {
        public string? Name { get; set; }
    }
}
